; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33134.0 

	TITLE	W:\WindowsGame\build\win32_barebones.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z	; XInputGetStateStub
PUBLIC	?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ; XInputSetStateStub
CONST	SEGMENT
$SG98393 DB	'WM_CLOSE', 0aH, 00H
	ORG $+2
$SG98395 DB	'WM_ACTIVATEAPP', 0aH, 00H
$SG98397 DB	'WM_DESTROY', 0aH, 00H
$SG98405 DB	'W: ', 00H
$SG98408 DB	'isDown ', 00H
$SG98410 DB	'wasDown ', 00H
	ORG $+3
$SG98411 DB	0aH, 00H
	ORG $+2
$SG98512 DB	'BareBonesWindowClass', 00H
	ORG $+3
$SG98515 DB	'Bare Bones', 00H
	ORG $+1
$SG98261 DB	'xinput1_4.dll', 00H
	ORG $+2
$SG98264 DB	'XInputGetState', 00H
	ORG $+1
$SG98266 DB	'XInputSetState', 00H
	ORG $+1
$SG98287 DB	'dsound.dll', 00H
	ORG $+1
$SG98290 DB	'DirectSoundCreate', 00H
	ORG $+2
$SG98299 DB	'Primary buffer format was set.', 0aH, 00H
$SG98302 DB	'Primary buffer format was set.', 0aH, 00H
CONST	ENDS
PUBLIC	_sinf
PUBLIC	_main
PUBLIC	?WinMainA@@YGHPAUHINSTANCE__@@0PADH@Z		; WinMainA
PUBLIC	__real@40c90fdb
PUBLIC	__real@43800000
PUBLIC	__real@447a0000
PUBLIC	__real@46ea6000
PUBLIC	__real@49742400
EXTRN	_sin:PROC
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__VirtualAlloc@16:PROC
EXTRN	__imp__VirtualFree@12:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__StretchDIBits@52:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ltod3:PROC
EXTRN	__ultod3:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?tSine@?1??GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z@4MA
_BSS	SEGMENT
?tSine@?1??GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z@4MA DD 01H DUP (?) ; `GameOutputSound'::`2'::tSine
_BSS	ENDS
_BSS	SEGMENT
?g_running@@3HA DD 01H DUP (?)				; g_running
?g_back_buffer@@3Uwin32_offscreen_buffer@@A DB 03cH DUP (?) ; g_back_buffer
?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A DD 01H DUP (?) ; g_secondary_buffer
_BSS	ENDS
;	COMDAT __real@49742400
CONST	SEGMENT
__real@49742400 DD 049742400r			; 1e+06
CONST	ENDS
;	COMDAT __real@46ea6000
CONST	SEGMENT
__real@46ea6000 DD 046ea6000r			; 30000
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
_DATA	SEGMENT
?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA DD FLAT:?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z ; xInputGetState_
?xInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA DD FLAT:?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ; xInputSetState_
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_main
	DD	010H
	DD	06d7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z
	DD	0dH
	DD	01e3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Win32GetWindowDimensions@@YA?AUwin32_window_dimensions@@PAUHWND__@@@Z
	DD	0dH
	DD	036H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Win32InitDSound@@YAXPAUHWND__@@HH@Z
	DD	0dH
	DD	0180H
voltbl	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_Instance$ = 8						; size = 4
_PrevInstance$ = 12					; size = 4
_CmdLine$ = 16						; size = 4
_ShowCode$ = 20						; size = 4
?WinMainA@@YGHPAUHINSTANCE__@@0PADH@Z PROC		; WinMainA

; 641  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 	main(Instance);

  00003	8b 45 08	 mov	 eax, DWORD PTR _Instance$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _main
  0000c	83 c4 04	 add	 esp, 4

; 643  : 
; 644  : 	return(0);

  0000f	33 c0		 xor	 eax, eax

; 645  : }

  00011	5d		 pop	 ebp
  00012	c2 10 00	 ret	 16			; 00000010H
?WinMainA@@YGHPAUHINSTANCE__@@0PADH@Z ENDP		; WinMainA
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_Message$1 = -380					; size = 28
_buttonY$2 = -352					; size = 4
_buttonX$3 = -348					; size = 4
_buttonB$4 = -344					; size = 4
_buttonA$5 = -340					; size = 4
_thumbRight$6 = -336					; size = 4
_shoulderRight$7 = -332					; size = 4
_shoulderLeft$8 = -328					; size = 4
_dPadUp$9 = -324					; size = 4
_dPadDown$10 = -320					; size = 4
_dPadLeft$11 = -316					; size = 4
_dPadRight$12 = -312					; size = 4
_buttonStart$13 = -308					; size = 4
_buttonBack$14 = -304					; size = 4
_thumbLeft$15 = -300					; size = 4
_MegaCyclePerFrame$16 = -296				; size = 4
_fps$17 = -292						; size = 4
_mSPerFrame$18 = -288					; size = 4
_writeCursor$19 = -284					; size = 4
_perfCountFreqResult$ = -280				; size = 8
_WindowClass$ = -272					; size = 40
_cyclesElapsed$20 = -232				; size = 8
_dimensions$21 = -224					; size = 8
$T22 = -216						; size = 8
tv577 = -208						; size = 4
tv575 = -204						; size = 4
_DeviceContext$23 = -200				; size = 4
_samples$24 = -196					; size = 4
_targetCursor$25 = -192					; size = 4
_inputState$26 = -188					; size = 4
_stickRX$27 = -184					; size = 2
_buffer$28 = -180					; size = 16
_endCounter$29 = -164					; size = 8
_lastCounter$30 = -156					; size = 8
_soundBuffer$31 = -148					; size = 12
_perfCountFrequency$ = -136				; size = 8
_counterElapsed$32 = -128				; size = 8
_endCycleCount$33 = -120				; size = 8
_lastCycleCount$34 = -112				; size = 8
_soundIsValid$35 = -104					; size = 4
_yOffset$36 = -100					; size = 4
_xOffset$37 = -96					; size = 4
_stickLX$38 = -92					; size = 2
_stickRY$39 = -88					; size = 2
_stickLY$40 = -84					; size = 2
_Window$41 = -80					; size = 4
_playCursor$42 = -76					; size = 4
_ctrlIndex$43 = -72					; size = 4
_byteToLock$44 = -68					; size = 4
_bytesToWrite$45 = -64					; size = 4
_pad$46 = -60						; size = 4
_state$47 = -56						; size = 16
_soundOutput$48 = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
_Instance$ = 8						; size = 4
_main	PROC

; 430  : int main(HINSTANCE Instance) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 7c 01 00
	00		 sub	 esp, 380		; 0000017cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 431  : 	LARGE_INTEGER perfCountFreqResult;
; 432  : 	QueryPerformanceFrequency(&perfCountFreqResult);

  00013	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _perfCountFreqResult$[ebp]
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceFrequency@4

; 433  : 	int64 perfCountFrequency = perfCountFreqResult.QuadPart;

  00020	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _perfCountFreqResult$[ebp]
  00026	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _perfCountFreqResult$[ebp+4]
  0002c	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _perfCountFrequency$[ebp], ecx
  00032	89 95 7c ff ff
	ff		 mov	 DWORD PTR _perfCountFrequency$[ebp+4], edx

; 434  : 
; 435  : 	Win32LoadXInput();

  00038	e8 00 00 00 00	 call	 ?Win32LoadXInput@@YAXXZ	; Win32LoadXInput

; 436  : 
; 437  : 	WNDCLASSA WindowClass = {};

  0003d	33 c0		 xor	 eax, eax
  0003f	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp], eax
  00045	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+4], eax
  0004b	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+8], eax
  00051	89 85 fc fe ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+12], eax
  00057	89 85 00 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+16], eax
  0005d	89 85 04 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+20], eax
  00063	89 85 08 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+24], eax
  00069	89 85 0c ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+28], eax
  0006f	89 85 10 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+32], eax
  00075	89 85 14 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+36], eax

; 438  : 
; 439  : 	Win32ResizeDIBSection(&g_back_buffer, 1280, 720);

  0007b	68 d0 02 00 00	 push	 720			; 000002d0H
  00080	68 00 05 00 00	 push	 1280			; 00000500H
  00085	68 00 00 00 00	 push	 OFFSET ?g_back_buffer@@3Uwin32_offscreen_buffer@@A
  0008a	e8 00 00 00 00	 call	 ?Win32ResizeDIBSection@@YAXPAUwin32_offscreen_buffer@@HH@Z ; Win32ResizeDIBSection
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 440  : 
; 441  : 	WindowClass.style = CS_HREDRAW | CS_VREDRAW;

  00092	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp], 3

; 442  : 	WindowClass.lpfnWndProc = Win32MainWindowCallback;

  0009c	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp+4], OFFSET ?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z ; Win32MainWindowCallback

; 443  : 	WindowClass.hInstance = Instance;

  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _Instance$[ebp]
  000a9	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+16], ecx

; 444  : 	WindowClass.lpszClassName = "BareBonesWindowClass";

  000af	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp+36], OFFSET $SG98512

; 445  : 
; 446  : 	if (RegisterClassA(&WindowClass))

  000b9	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _WindowClass$[ebp]
  000bf	52		 push	 edx
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassA@4
  000c6	0f b7 c0	 movzx	 eax, ax
  000c9	85 c0		 test	 eax, eax
  000cb	0f 84 04 06 00
	00		 je	 $LN9@main

; 447  : 	{
; 448  : 		HWND Window = CreateWindowExA(

  000d1	6a 00		 push	 0
  000d3	8b 4d 08	 mov	 ecx, DWORD PTR _Instance$[ebp]
  000d6	51		 push	 ecx
  000d7	6a 00		 push	 0
  000d9	6a 00		 push	 0
  000db	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000e0	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000e5	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000ea	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000ef	68 00 00 cf 10	 push	 282001408		; 10cf0000H
  000f4	68 00 00 00 00	 push	 OFFSET $SG98515
  000f9	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _WindowClass$[ebp+36]
  000ff	52		 push	 edx
  00100	6a 00		 push	 0
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  00108	89 45 b0	 mov	 DWORD PTR _Window$41[ebp], eax

; 449  : 			0,
; 450  : 			WindowClass.lpszClassName,
; 451  : 			"Bare Bones",
; 452  : 			WS_OVERLAPPEDWINDOW | WS_VISIBLE,
; 453  : 			CW_USEDEFAULT,
; 454  : 			CW_USEDEFAULT,
; 455  : 			CW_USEDEFAULT,
; 456  : 			CW_USEDEFAULT,
; 457  : 			0,
; 458  : 			0,
; 459  : 			Instance,
; 460  : 			0);
; 461  : 		if (Window)

  0010b	83 7d b0 00	 cmp	 DWORD PTR _Window$41[ebp], 0
  0010f	0f 84 c0 05 00
	00		 je	 $LN11@main

; 462  : 		{
; 463  : 			HDC DeviceContext = GetDC(Window);

  00115	8b 45 b0	 mov	 eax, DWORD PTR _Window$41[ebp]
  00118	50		 push	 eax
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  0011f	89 85 38 ff ff
	ff		 mov	 DWORD PTR _DeviceContext$23[ebp], eax

; 464  : 
; 465  : 			// Graphics Test
; 466  : 			int xOffset = 0;

  00125	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _xOffset$37[ebp], 0

; 467  : 			int yOffset = 0;

  0012c	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _yOffset$36[ebp], 0

; 468  : 
; 469  : 			// Sound Test
; 470  : 			win32_sound_output soundOutput = {};

  00133	33 c9		 xor	 ecx, ecx
  00135	89 4d d8	 mov	 DWORD PTR _soundOutput$48[ebp], ecx
  00138	89 4d dc	 mov	 DWORD PTR _soundOutput$48[ebp+4], ecx
  0013b	89 4d e0	 mov	 DWORD PTR _soundOutput$48[ebp+8], ecx
  0013e	89 4d e4	 mov	 DWORD PTR _soundOutput$48[ebp+12], ecx
  00141	89 4d e8	 mov	 DWORD PTR _soundOutput$48[ebp+16], ecx
  00144	89 4d ec	 mov	 DWORD PTR _soundOutput$48[ebp+20], ecx
  00147	89 4d f0	 mov	 DWORD PTR _soundOutput$48[ebp+24], ecx
  0014a	89 4d f4	 mov	 DWORD PTR _soundOutput$48[ebp+28], ecx
  0014d	89 4d f8	 mov	 DWORD PTR _soundOutput$48[ebp+32], ecx

; 471  : 
; 472  : 			soundOutput.samplesPerSec = 48000;

  00150	c7 45 d8 80 bb
	00 00		 mov	 DWORD PTR _soundOutput$48[ebp], 48000 ; 0000bb80H

; 473  : 			soundOutput.toneHz = 256;

  00157	c7 45 dc 00 01
	00 00		 mov	 DWORD PTR _soundOutput$48[ebp+4], 256 ; 00000100H

; 474  : 			soundOutput.toneVolume = 300;

  0015e	ba 2c 01 00 00	 mov	 edx, 300		; 0000012cH
  00163	66 89 55 e0	 mov	 WORD PTR _soundOutput$48[ebp+8], dx

; 475  : 			soundOutput.runningSampleIndex = 0;

  00167	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _soundOutput$48[ebp+12], 0

; 476  : 			soundOutput.wavePeriod = soundOutput.samplesPerSec / soundOutput.toneHz;

  0016e	8b 45 d8	 mov	 eax, DWORD PTR _soundOutput$48[ebp]
  00171	99		 cdq
  00172	f7 7d dc	 idiv	 DWORD PTR _soundOutput$48[ebp+4]
  00175	89 45 e8	 mov	 DWORD PTR _soundOutput$48[ebp+16], eax

; 477  : 			soundOutput.bytesPerSample = sizeof(int16) * 2;

  00178	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _soundOutput$48[ebp+20], 4

; 478  : 			soundOutput.bufferSize = soundOutput.samplesPerSec * soundOutput.bytesPerSample;

  0017f	8b 45 d8	 mov	 eax, DWORD PTR _soundOutput$48[ebp]
  00182	0f af 45 ec	 imul	 eax, DWORD PTR _soundOutput$48[ebp+20]
  00186	89 45 f0	 mov	 DWORD PTR _soundOutput$48[ebp+24], eax

; 479  : 			soundOutput.latencySample = soundOutput.samplesPerSec / 15;

  00189	8b 45 d8	 mov	 eax, DWORD PTR _soundOutput$48[ebp]
  0018c	99		 cdq
  0018d	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00192	f7 f9		 idiv	 ecx
  00194	89 45 f8	 mov	 DWORD PTR _soundOutput$48[ebp+32], eax

; 480  : 
; 481  : 			Win32InitDSound(Window, soundOutput.samplesPerSec, soundOutput.bufferSize);

  00197	8b 55 f0	 mov	 edx, DWORD PTR _soundOutput$48[ebp+24]
  0019a	52		 push	 edx
  0019b	8b 45 d8	 mov	 eax, DWORD PTR _soundOutput$48[ebp]
  0019e	50		 push	 eax
  0019f	8b 4d b0	 mov	 ecx, DWORD PTR _Window$41[ebp]
  001a2	51		 push	 ecx
  001a3	e8 00 00 00 00	 call	 ?Win32InitDSound@@YAXPAUHWND__@@HH@Z ; Win32InitDSound
  001a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 482  : 			Win32ClearBuffer(&soundOutput);

  001ab	8d 55 d8	 lea	 edx, DWORD PTR _soundOutput$48[ebp]
  001ae	52		 push	 edx
  001af	e8 00 00 00 00	 call	 ?Win32ClearBuffer@@YAXPAUwin32_sound_output@@@Z ; Win32ClearBuffer
  001b4	83 c4 04	 add	 esp, 4

; 483  : 			g_secondary_buffer->Play(0, 0, DSBPLAY_LOOPING);

  001b7	6a 01		 push	 1
  001b9	6a 00		 push	 0
  001bb	6a 00		 push	 0
  001bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  001c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  001ca	52		 push	 edx
  001cb	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  001ce	ff d0		 call	 eax

; 484  : 			int16* samples = (int16 *)VirtualAlloc(0, 48000*2*sizeof(int16), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

  001d0	6a 04		 push	 4
  001d2	68 00 30 00 00	 push	 12288			; 00003000H
  001d7	68 00 ee 02 00	 push	 192000			; 0002ee00H
  001dc	6a 00		 push	 0
  001de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
  001e4	89 85 3c ff ff
	ff		 mov	 DWORD PTR _samples$24[ebp], eax

; 485  : 
; 486  : 			g_running = true;

  001ea	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_running@@3HA, 1

; 487  : 
; 488  : 			LARGE_INTEGER lastCounter;
; 489  : 			QueryPerformanceCounter(&lastCounter);

  001f4	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _lastCounter$30[ebp]
  001fa	51		 push	 ecx
  001fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4

; 490  : 			uint64 lastCycleCount = __rdtsc();

  00201	0f 31		 rdtsc
  00203	89 45 90	 mov	 DWORD PTR _lastCycleCount$34[ebp], eax
  00206	89 55 94	 mov	 DWORD PTR _lastCycleCount$34[ebp+4], edx
$LN2@main:

; 491  : 			while (g_running)

  00209	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_running@@3HA, 0
  00210	0f 84 bf 04 00
	00		 je	 $LN3@main
$LN4@main:

; 492  : 			{
; 493  : 				MSG Message;
; 494  : 				while (PeekMessage(&Message, 0, 0, 0, PM_REMOVE))

  00216	6a 01		 push	 1
  00218	6a 00		 push	 0
  0021a	6a 00		 push	 0
  0021c	6a 00		 push	 0
  0021e	8d 95 84 fe ff
	ff		 lea	 edx, DWORD PTR _Message$1[ebp]
  00224	52		 push	 edx
  00225	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  0022b	85 c0		 test	 eax, eax
  0022d	74 2f		 je	 SHORT $LN5@main

; 495  : 				{
; 496  : 					if (Message.message == WM_QUIT)

  0022f	83 bd 88 fe ff
	ff 12		 cmp	 DWORD PTR _Message$1[ebp+4], 18 ; 00000012H
  00236	75 0a		 jne	 SHORT $LN13@main

; 497  : 					{
; 498  : 						g_running = false;

  00238	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_running@@3HA, 0
$LN13@main:

; 499  : 					}
; 500  : 
; 501  : 					TranslateMessage(&Message);

  00242	8d 85 84 fe ff
	ff		 lea	 eax, DWORD PTR _Message$1[ebp]
  00248	50		 push	 eax
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TranslateMessage@4

; 502  : 					DispatchMessageA(&Message);

  0024f	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR _Message$1[ebp]
  00255	51		 push	 ecx
  00256	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DispatchMessageA@4

; 503  : 				}

  0025c	eb b8		 jmp	 SHORT $LN4@main
$LN5@main:

; 504  : 
; 505  : 				// Controller
; 506  : 				for (DWORD ctrlIndex = 0; ctrlIndex < XUSER_MAX_COUNT; ++ctrlIndex)

  0025e	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _ctrlIndex$43[ebp], 0
  00265	eb 09		 jmp	 SHORT $LN8@main
$LN6@main:
  00267	8b 55 b8	 mov	 edx, DWORD PTR _ctrlIndex$43[ebp]
  0026a	83 c2 01	 add	 edx, 1
  0026d	89 55 b8	 mov	 DWORD PTR _ctrlIndex$43[ebp], edx
$LN8@main:
  00270	83 7d b8 04	 cmp	 DWORD PTR _ctrlIndex$43[ebp], 4
  00274	0f 83 9a 01 00
	00		 jae	 $LN7@main

; 507  : 				{
; 508  : 					XINPUT_STATE state;
; 509  : 					DWORD inputState = XInputGetState(ctrlIndex, &state);

  0027a	8d 45 c8	 lea	 eax, DWORD PTR _state$47[ebp]
  0027d	50		 push	 eax
  0027e	8b 4d b8	 mov	 ecx, DWORD PTR _ctrlIndex$43[ebp]
  00281	51		 push	 ecx
  00282	ff 15 00 00 00
	00		 call	 DWORD PTR ?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA
  00288	89 85 44 ff ff
	ff		 mov	 DWORD PTR _inputState$26[ebp], eax

; 510  : 
; 511  : 					// Controller Mapping
; 512  : 					if (inputState == ERROR_SUCCESS)

  0028e	83 bd 44 ff ff
	ff 00		 cmp	 DWORD PTR _inputState$26[ebp], 0
  00295	0f 85 74 01 00
	00		 jne	 $LN14@main

; 513  : 					{
; 514  : 						// This controller is plugged in
; 515  : 						XINPUT_GAMEPAD* pad = &state.Gamepad;

  0029b	8d 55 cc	 lea	 edx, DWORD PTR _state$47[ebp+4]
  0029e	89 55 c4	 mov	 DWORD PTR _pad$46[ebp], edx

; 516  : 
; 517  : 						bool32 dPadUp = (pad->wButtons & XINPUT_GAMEPAD_DPAD_UP);

  002a1	8b 45 c4	 mov	 eax, DWORD PTR _pad$46[ebp]
  002a4	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  002a7	83 e1 01	 and	 ecx, 1
  002aa	89 8d bc fe ff
	ff		 mov	 DWORD PTR _dPadUp$9[ebp], ecx

; 518  : 						bool32 dPadDown = (pad->wButtons & XINPUT_GAMEPAD_DPAD_DOWN);

  002b0	8b 55 c4	 mov	 edx, DWORD PTR _pad$46[ebp]
  002b3	0f b7 02	 movzx	 eax, WORD PTR [edx]
  002b6	83 e0 02	 and	 eax, 2
  002b9	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _dPadDown$10[ebp], eax

; 519  : 						bool32 dPadLeft = (pad->wButtons & XINPUT_GAMEPAD_DPAD_LEFT);

  002bf	8b 4d c4	 mov	 ecx, DWORD PTR _pad$46[ebp]
  002c2	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  002c5	83 e2 04	 and	 edx, 4
  002c8	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _dPadLeft$11[ebp], edx

; 520  : 						bool32 dPadRight = (pad->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT);

  002ce	8b 45 c4	 mov	 eax, DWORD PTR _pad$46[ebp]
  002d1	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  002d4	83 e1 08	 and	 ecx, 8
  002d7	89 8d c8 fe ff
	ff		 mov	 DWORD PTR _dPadRight$12[ebp], ecx

; 521  : 						bool32 buttonStart = (pad->wButtons & XINPUT_GAMEPAD_START);

  002dd	8b 55 c4	 mov	 edx, DWORD PTR _pad$46[ebp]
  002e0	0f b7 02	 movzx	 eax, WORD PTR [edx]
  002e3	83 e0 10	 and	 eax, 16			; 00000010H
  002e6	89 85 cc fe ff
	ff		 mov	 DWORD PTR _buttonStart$13[ebp], eax

; 522  : 						bool32 buttonBack = (pad->wButtons & XINPUT_GAMEPAD_BACK);

  002ec	8b 4d c4	 mov	 ecx, DWORD PTR _pad$46[ebp]
  002ef	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  002f2	83 e2 20	 and	 edx, 32			; 00000020H
  002f5	89 95 d0 fe ff
	ff		 mov	 DWORD PTR _buttonBack$14[ebp], edx

; 523  : 						bool32 thumbLeft = (pad->wButtons & XINPUT_GAMEPAD_LEFT_THUMB);

  002fb	8b 45 c4	 mov	 eax, DWORD PTR _pad$46[ebp]
  002fe	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00301	83 e1 40	 and	 ecx, 64			; 00000040H
  00304	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _thumbLeft$15[ebp], ecx

; 524  : 						bool32 thumbRight = (pad->wButtons & XINPUT_GAMEPAD_RIGHT_THUMB);

  0030a	8b 55 c4	 mov	 edx, DWORD PTR _pad$46[ebp]
  0030d	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00310	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00315	89 85 b0 fe ff
	ff		 mov	 DWORD PTR _thumbRight$6[ebp], eax

; 525  : 						bool32 shoulderLeft = (pad->wButtons & XINPUT_GAMEPAD_LEFT_SHOULDER);

  0031b	8b 4d c4	 mov	 ecx, DWORD PTR _pad$46[ebp]
  0031e	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00321	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  00327	89 95 b8 fe ff
	ff		 mov	 DWORD PTR _shoulderLeft$8[ebp], edx

; 526  : 						bool32 shoulderRight = (pad->wButtons & XINPUT_GAMEPAD_RIGHT_SHOULDER);

  0032d	8b 45 c4	 mov	 eax, DWORD PTR _pad$46[ebp]
  00330	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00333	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00339	89 8d b4 fe ff
	ff		 mov	 DWORD PTR _shoulderRight$7[ebp], ecx

; 527  : 						bool32 buttonA = (pad->wButtons & XINPUT_GAMEPAD_A);

  0033f	8b 55 c4	 mov	 edx, DWORD PTR _pad$46[ebp]
  00342	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00345	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  0034a	89 85 ac fe ff
	ff		 mov	 DWORD PTR _buttonA$5[ebp], eax

; 528  : 						bool32 buttonB = (pad->wButtons & XINPUT_GAMEPAD_B);

  00350	8b 4d c4	 mov	 ecx, DWORD PTR _pad$46[ebp]
  00353	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00356	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  0035c	89 95 a8 fe ff
	ff		 mov	 DWORD PTR _buttonB$4[ebp], edx

; 529  : 						bool32 buttonX = (pad->wButtons & XINPUT_GAMEPAD_X);

  00362	8b 45 c4	 mov	 eax, DWORD PTR _pad$46[ebp]
  00365	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00368	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  0036e	89 8d a4 fe ff
	ff		 mov	 DWORD PTR _buttonX$3[ebp], ecx

; 530  : 						bool32 buttonY = (pad->wButtons & XINPUT_GAMEPAD_Y);

  00374	8b 55 c4	 mov	 edx, DWORD PTR _pad$46[ebp]
  00377	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0037a	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  0037f	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _buttonY$2[ebp], eax

; 531  : 
; 532  : 						int16 stickLX = pad->sThumbLX;

  00385	8b 4d c4	 mov	 ecx, DWORD PTR _pad$46[ebp]
  00388	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  0038c	66 89 55 a4	 mov	 WORD PTR _stickLX$38[ebp], dx

; 533  : 						int16 stickLY = pad->sThumbLY;

  00390	8b 45 c4	 mov	 eax, DWORD PTR _pad$46[ebp]
  00393	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  00397	66 89 4d ac	 mov	 WORD PTR _stickLY$40[ebp], cx

; 534  : 						int16 stickRX = pad->sThumbRX;

  0039b	8b 55 c4	 mov	 edx, DWORD PTR _pad$46[ebp]
  0039e	66 8b 42 08	 mov	 ax, WORD PTR [edx+8]
  003a2	66 89 85 48 ff
	ff ff		 mov	 WORD PTR _stickRX$27[ebp], ax

; 535  : 						int16 stickRY = pad->sThumbRY;

  003a9	8b 4d c4	 mov	 ecx, DWORD PTR _pad$46[ebp]
  003ac	66 8b 51 0a	 mov	 dx, WORD PTR [ecx+10]
  003b0	66 89 55 a8	 mov	 WORD PTR _stickRY$39[ebp], dx

; 536  : 
; 537  : 						// doesn't properly deal with deadzone
; 538  : 						xOffset += stickLX / 4096;

  003b4	0f bf 45 a4	 movsx	 eax, WORD PTR _stickLX$38[ebp]
  003b8	99		 cdq
  003b9	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  003bf	03 c2		 add	 eax, edx
  003c1	c1 f8 0c	 sar	 eax, 12			; 0000000cH
  003c4	03 45 a0	 add	 eax, DWORD PTR _xOffset$37[ebp]
  003c7	89 45 a0	 mov	 DWORD PTR _xOffset$37[ebp], eax

; 539  : 						yOffset += stickLY / 4096;

  003ca	0f bf 45 ac	 movsx	 eax, WORD PTR _stickLY$40[ebp]
  003ce	99		 cdq
  003cf	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  003d5	03 c2		 add	 eax, edx
  003d7	c1 f8 0c	 sar	 eax, 12			; 0000000cH
  003da	03 45 9c	 add	 eax, DWORD PTR _yOffset$36[ebp]
  003dd	89 45 9c	 mov	 DWORD PTR _yOffset$36[ebp], eax

; 540  : 
; 541  : 						soundOutput.toneHz = 512 + (int)(256.0f * ((real32)stickRY / 30000.0f));

  003e0	0f bf 45 a8	 movsx	 eax, WORD PTR _stickRY$39[ebp]
  003e4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  003e8	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46ea6000
  003f0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@43800000
  003f8	f3 0f 2c c8	 cvttss2si ecx, xmm0
  003fc	81 c1 00 02 00
	00		 add	 ecx, 512		; 00000200H
  00402	89 4d dc	 mov	 DWORD PTR _soundOutput$48[ebp+4], ecx

; 542  : 						soundOutput.wavePeriod = soundOutput.samplesPerSec / soundOutput.toneHz;

  00405	8b 45 d8	 mov	 eax, DWORD PTR _soundOutput$48[ebp]
  00408	99		 cdq
  00409	f7 7d dc	 idiv	 DWORD PTR _soundOutput$48[ebp+4]
  0040c	89 45 e8	 mov	 DWORD PTR _soundOutput$48[ebp+16], eax
$LN14@main:

; 543  : 					}
; 544  : 					else
; 545  : 					{
; 546  : 						// This controller is not available
; 547  : 					}
; 548  : 				}

  0040f	e9 53 fe ff ff	 jmp	 $LN6@main
$LN7@main:

; 549  : 
; 550  : 				DWORD byteToLock;
; 551  : 				DWORD targetCursor;
; 552  : 				DWORD bytesToWrite = 0;

  00414	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _bytesToWrite$45[ebp], 0

; 553  : 				DWORD playCursor;
; 554  : 				DWORD writeCursor;
; 555  : 				bool32 soundIsValid = false;

  0041b	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _soundIsValid$35[ebp], 0

; 556  : 				if (SUCCEEDED(g_secondary_buffer->GetCurrentPosition(&playCursor, &writeCursor)))

  00422	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _writeCursor$19[ebp]
  00428	52		 push	 edx
  00429	8d 45 b4	 lea	 eax, DWORD PTR _playCursor$42[ebp]
  0042c	50		 push	 eax
  0042d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  00433	8b 11		 mov	 edx, DWORD PTR [ecx]
  00435	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  0043a	50		 push	 eax
  0043b	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0043e	ff d1		 call	 ecx
  00440	85 c0		 test	 eax, eax
  00442	7c 63		 jl	 SHORT $LN16@main

; 557  : 				{
; 558  : 					byteToLock = ((soundOutput.runningSampleIndex * soundOutput.bytesPerSample)

  00444	8b 45 e4	 mov	 eax, DWORD PTR _soundOutput$48[ebp+12]
  00447	0f af 45 ec	 imul	 eax, DWORD PTR _soundOutput$48[ebp+20]
  0044b	33 d2		 xor	 edx, edx
  0044d	f7 75 f0	 div	 DWORD PTR _soundOutput$48[ebp+24]
  00450	89 55 bc	 mov	 DWORD PTR _byteToLock$44[ebp], edx

; 559  : 						% soundOutput.bufferSize);
; 560  : 					targetCursor = playCursor +

  00453	8b 45 f8	 mov	 eax, DWORD PTR _soundOutput$48[ebp+32]
  00456	0f af 45 ec	 imul	 eax, DWORD PTR _soundOutput$48[ebp+20]
  0045a	99		 cdq
  0045b	f7 7d f0	 idiv	 DWORD PTR _soundOutput$48[ebp+24]
  0045e	03 55 b4	 add	 edx, DWORD PTR _playCursor$42[ebp]
  00461	89 95 40 ff ff
	ff		 mov	 DWORD PTR _targetCursor$25[ebp], edx

; 561  : 						(soundOutput.latencySample * soundOutput.bytesPerSample) %
; 562  : 						soundOutput.bufferSize;
; 563  : 
; 564  : 					if (byteToLock == playCursor)

  00467	8b 55 bc	 mov	 edx, DWORD PTR _byteToLock$44[ebp]
  0046a	3b 55 b4	 cmp	 edx, DWORD PTR _playCursor$42[ebp]
  0046d	75 09		 jne	 SHORT $LN17@main

; 565  : 					{
; 566  : 						bytesToWrite = 0;

  0046f	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _bytesToWrite$45[ebp], 0

; 567  : 					}

  00476	eb 28		 jmp	 SHORT $LN20@main
$LN17@main:

; 568  : 					else if (byteToLock > playCursor)

  00478	8b 45 bc	 mov	 eax, DWORD PTR _byteToLock$44[ebp]
  0047b	3b 45 b4	 cmp	 eax, DWORD PTR _playCursor$42[ebp]
  0047e	76 14		 jbe	 SHORT $LN19@main

; 569  : 					{
; 570  : 						bytesToWrite = (soundOutput.bufferSize - byteToLock);

  00480	8b 4d f0	 mov	 ecx, DWORD PTR _soundOutput$48[ebp+24]
  00483	2b 4d bc	 sub	 ecx, DWORD PTR _byteToLock$44[ebp]
  00486	89 4d c0	 mov	 DWORD PTR _bytesToWrite$45[ebp], ecx

; 571  : 						bytesToWrite += playCursor;

  00489	8b 55 c0	 mov	 edx, DWORD PTR _bytesToWrite$45[ebp]
  0048c	03 55 b4	 add	 edx, DWORD PTR _playCursor$42[ebp]
  0048f	89 55 c0	 mov	 DWORD PTR _bytesToWrite$45[ebp], edx

; 572  : 					}

  00492	eb 0c		 jmp	 SHORT $LN20@main
$LN19@main:

; 573  : 					else
; 574  : 					{
; 575  : 						bytesToWrite = targetCursor - byteToLock;

  00494	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _targetCursor$25[ebp]
  0049a	2b 45 bc	 sub	 eax, DWORD PTR _byteToLock$44[ebp]
  0049d	89 45 c0	 mov	 DWORD PTR _bytesToWrite$45[ebp], eax
$LN20@main:

; 576  : 					}
; 577  : 
; 578  : 					soundIsValid = true;

  004a0	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _soundIsValid$35[ebp], 1
$LN16@main:

; 579  : 				}
; 580  : 
; 581  : 				game_sound_output_buffer soundBuffer = {};

  004a7	33 c9		 xor	 ecx, ecx
  004a9	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _soundBuffer$31[ebp], ecx
  004af	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _soundBuffer$31[ebp+4], ecx
  004b5	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _soundBuffer$31[ebp+8], ecx

; 582  : 				soundBuffer.samplesPerSec = soundOutput.samplesPerSec;

  004bb	8b 55 d8	 mov	 edx, DWORD PTR _soundOutput$48[ebp]
  004be	89 95 6c ff ff
	ff		 mov	 DWORD PTR _soundBuffer$31[ebp], edx

; 583  : 				soundBuffer.sampleCount = bytesToWrite / soundOutput.bytesPerSample;

  004c4	8b 45 c0	 mov	 eax, DWORD PTR _bytesToWrite$45[ebp]
  004c7	33 d2		 xor	 edx, edx
  004c9	f7 75 ec	 div	 DWORD PTR _soundOutput$48[ebp+20]
  004cc	89 85 70 ff ff
	ff		 mov	 DWORD PTR _soundBuffer$31[ebp+4], eax

; 584  : 				soundBuffer.samples = samples;

  004d2	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _samples$24[ebp]
  004d8	89 85 74 ff ff
	ff		 mov	 DWORD PTR _soundBuffer$31[ebp+8], eax

; 585  : 
; 586  : 				game_offscreen_buffer buffer = {};

  004de	33 c9		 xor	 ecx, ecx
  004e0	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _buffer$28[ebp], ecx
  004e6	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _buffer$28[ebp+4], ecx
  004ec	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _buffer$28[ebp+8], ecx
  004f2	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _buffer$28[ebp+12], ecx

; 587  : 				buffer.memory = g_back_buffer.memory;

  004f8	8b 15 2c 00 00
	00		 mov	 edx, DWORD PTR ?g_back_buffer@@3Uwin32_offscreen_buffer@@A+44
  004fe	89 95 4c ff ff
	ff		 mov	 DWORD PTR _buffer$28[ebp], edx

; 588  : 				buffer.width = g_back_buffer.width;

  00504	a1 30 00 00 00	 mov	 eax, DWORD PTR ?g_back_buffer@@3Uwin32_offscreen_buffer@@A+48
  00509	89 85 50 ff ff
	ff		 mov	 DWORD PTR _buffer$28[ebp+4], eax

; 589  : 				buffer.height = g_back_buffer.height;

  0050f	8b 0d 34 00 00
	00		 mov	 ecx, DWORD PTR ?g_back_buffer@@3Uwin32_offscreen_buffer@@A+52
  00515	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _buffer$28[ebp+8], ecx

; 590  : 				buffer.pitch = g_back_buffer.pitch;

  0051b	8b 15 38 00 00
	00		 mov	 edx, DWORD PTR ?g_back_buffer@@3Uwin32_offscreen_buffer@@A+56
  00521	89 95 58 ff ff
	ff		 mov	 DWORD PTR _buffer$28[ebp+12], edx

; 591  : 				GameUpdateAndRender(&buffer, &soundBuffer, soundOutput.toneHz);

  00527	8b 45 dc	 mov	 eax, DWORD PTR _soundOutput$48[ebp+4]
  0052a	50		 push	 eax
  0052b	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _soundBuffer$31[ebp]
  00531	51		 push	 ecx
  00532	8d 95 4c ff ff
	ff		 lea	 edx, DWORD PTR _buffer$28[ebp]
  00538	52		 push	 edx
  00539	e8 00 00 00 00	 call	 ?GameUpdateAndRender@@YAXPAUgame_offscreen_buffer@@PAUgame_sound_output_buffer@@H@Z ; GameUpdateAndRender
  0053e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  : 
; 593  : 				if (soundIsValid)

  00541	83 7d 98 00	 cmp	 DWORD PTR _soundIsValid$35[ebp], 0
  00545	74 1b		 je	 SHORT $LN21@main

; 594  : 				{
; 595  : 					Win32FillSoundBuffer(&soundOutput, &soundBuffer, byteToLock, bytesToWrite);

  00547	8b 45 c0	 mov	 eax, DWORD PTR _bytesToWrite$45[ebp]
  0054a	50		 push	 eax
  0054b	8b 4d bc	 mov	 ecx, DWORD PTR _byteToLock$44[ebp]
  0054e	51		 push	 ecx
  0054f	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _soundBuffer$31[ebp]
  00555	52		 push	 edx
  00556	8d 45 d8	 lea	 eax, DWORD PTR _soundOutput$48[ebp]
  00559	50		 push	 eax
  0055a	e8 00 00 00 00	 call	 ?Win32FillSoundBuffer@@YAXPAUwin32_sound_output@@PAUgame_sound_output_buffer@@KK@Z ; Win32FillSoundBuffer
  0055f	83 c4 10	 add	 esp, 16			; 00000010H
$LN21@main:

; 596  : 				}
; 597  : 
; 598  : 				win32_window_dimensions dimensions = Win32GetWindowDimensions(Window);

  00562	8b 4d b0	 mov	 ecx, DWORD PTR _Window$41[ebp]
  00565	51		 push	 ecx
  00566	e8 00 00 00 00	 call	 ?Win32GetWindowDimensions@@YA?AUwin32_window_dimensions@@PAUHWND__@@@Z ; Win32GetWindowDimensions
  0056b	83 c4 04	 add	 esp, 4
  0056e	89 85 28 ff ff
	ff		 mov	 DWORD PTR $T22[ebp], eax
  00574	89 95 2c ff ff
	ff		 mov	 DWORD PTR $T22[ebp+4], edx
  0057a	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR $T22[ebp]
  00580	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR $T22[ebp+4]
  00586	89 95 20 ff ff
	ff		 mov	 DWORD PTR _dimensions$21[ebp], edx
  0058c	89 85 24 ff ff
	ff		 mov	 DWORD PTR _dimensions$21[ebp+4], eax

; 599  : 				Win32DisplayBufferToWindow(

  00592	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _dimensions$21[ebp+4]
  00598	51		 push	 ecx
  00599	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _dimensions$21[ebp]
  0059f	52		 push	 edx
  005a0	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _DeviceContext$23[ebp]
  005a6	50		 push	 eax
  005a7	68 00 00 00 00	 push	 OFFSET ?g_back_buffer@@3Uwin32_offscreen_buffer@@A
  005ac	e8 00 00 00 00	 call	 ?Win32DisplayBufferToWindow@@YAXPAUwin32_offscreen_buffer@@PAUHDC__@@HH@Z ; Win32DisplayBufferToWindow
  005b1	83 c4 10	 add	 esp, 16			; 00000010H

; 600  : 					&g_back_buffer,
; 601  : 					DeviceContext,
; 602  : 					dimensions.width, dimensions.height);
; 603  : 
; 604  : 				uint64 endCycleCount = __rdtsc();

  005b4	0f 31		 rdtsc
  005b6	89 45 88	 mov	 DWORD PTR _endCycleCount$33[ebp], eax
  005b9	89 55 8c	 mov	 DWORD PTR _endCycleCount$33[ebp+4], edx

; 605  : 				LARGE_INTEGER endCounter;
; 606  : 				QueryPerformanceCounter(&endCounter);

  005bc	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _endCounter$29[ebp]
  005c2	51		 push	 ecx
  005c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4

; 607  : 
; 608  : 				// for debugging purposes
; 609  : 				uint64 cyclesElapsed = endCycleCount - lastCycleCount;

  005c9	8b 55 88	 mov	 edx, DWORD PTR _endCycleCount$33[ebp]
  005cc	2b 55 90	 sub	 edx, DWORD PTR _lastCycleCount$34[ebp]
  005cf	8b 45 8c	 mov	 eax, DWORD PTR _endCycleCount$33[ebp+4]
  005d2	1b 45 94	 sbb	 eax, DWORD PTR _lastCycleCount$34[ebp+4]
  005d5	89 95 18 ff ff
	ff		 mov	 DWORD PTR _cyclesElapsed$20[ebp], edx
  005db	89 85 1c ff ff
	ff		 mov	 DWORD PTR _cyclesElapsed$20[ebp+4], eax

; 610  : 				int64 counterElapsed = endCounter.QuadPart - lastCounter.QuadPart;

  005e1	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _endCounter$29[ebp]
  005e7	2b 8d 64 ff ff
	ff		 sub	 ecx, DWORD PTR _lastCounter$30[ebp]
  005ed	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _endCounter$29[ebp+4]
  005f3	1b 95 68 ff ff
	ff		 sbb	 edx, DWORD PTR _lastCounter$30[ebp+4]
  005f9	89 4d 80	 mov	 DWORD PTR _counterElapsed$32[ebp], ecx
  005fc	89 55 84	 mov	 DWORD PTR _counterElapsed$32[ebp+4], edx

; 611  : 				real32 mSPerFrame = (((1000.0f * (real32)counterElapsed) / (real32)perfCountFrequency));

  005ff	8b 55 84	 mov	 edx, DWORD PTR _counterElapsed$32[ebp+4]
  00602	8b 4d 80	 mov	 ecx, DWORD PTR _counterElapsed$32[ebp]
  00605	e8 00 00 00 00	 call	 __ltod3
  0060a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0060e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@447a0000
  00616	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _perfCountFrequency$[ebp+4]
  0061c	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _perfCountFrequency$[ebp]
  00622	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR tv575[ebp], xmm0
  0062a	e8 00 00 00 00	 call	 __ltod3
  0062f	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00633	f3 0f 10 8d 34
	ff ff ff	 movss	 xmm1, DWORD PTR tv575[ebp]
  0063b	f3 0f 5e c8	 divss	 xmm1, xmm0
  0063f	f3 0f 11 8d e0
	fe ff ff	 movss	 DWORD PTR _mSPerFrame$18[ebp], xmm1

; 612  : 				real32 fps = (real32)perfCountFrequency / (real32)counterElapsed;

  00647	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _perfCountFrequency$[ebp+4]
  0064d	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _perfCountFrequency$[ebp]
  00653	e8 00 00 00 00	 call	 __ltod3
  00658	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0065c	8b 55 84	 mov	 edx, DWORD PTR _counterElapsed$32[ebp+4]
  0065f	8b 4d 80	 mov	 ecx, DWORD PTR _counterElapsed$32[ebp]
  00662	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR tv577[ebp], xmm0
  0066a	e8 00 00 00 00	 call	 __ltod3
  0066f	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00673	f3 0f 10 8d 30
	ff ff ff	 movss	 xmm1, DWORD PTR tv577[ebp]
  0067b	f3 0f 5e c8	 divss	 xmm1, xmm0
  0067f	f3 0f 11 8d dc
	fe ff ff	 movss	 DWORD PTR _fps$17[ebp], xmm1

; 613  : 				real32 MegaCyclePerFrame = ((real32)cyclesElapsed / 1000000.0f);

  00687	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _cyclesElapsed$20[ebp+4]
  0068d	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _cyclesElapsed$20[ebp]
  00693	e8 00 00 00 00	 call	 __ultod3
  00698	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0069c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@49742400
  006a4	f3 0f 11 85 d8
	fe ff ff	 movss	 DWORD PTR _MegaCyclePerFrame$16[ebp], xmm0

; 614  : 
; 615  : 				//char buffer[256];
; 616  : 				//sprintf_s(buffer, "%.02fmspf | %.02ffps | %.02fMcpf\n", mSPerFrame, fps, MegaCyclePerFrame);
; 617  : 				//OutputDebugStringA(buffer);
; 618  : 				//end
; 619  : 
; 620  : 				lastCounter = endCounter;

  006ac	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _endCounter$29[ebp]
  006b2	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _endCounter$29[ebp+4]
  006b8	89 85 64 ff ff
	ff		 mov	 DWORD PTR _lastCounter$30[ebp], eax
  006be	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _lastCounter$30[ebp+4], ecx

; 621  : 				lastCycleCount = endCycleCount;

  006c4	8b 55 88	 mov	 edx, DWORD PTR _endCycleCount$33[ebp]
  006c7	8b 45 8c	 mov	 eax, DWORD PTR _endCycleCount$33[ebp+4]
  006ca	89 55 90	 mov	 DWORD PTR _lastCycleCount$34[ebp], edx
  006cd	89 45 94	 mov	 DWORD PTR _lastCycleCount$34[ebp+4], eax

; 622  : 			}

  006d0	e9 34 fb ff ff	 jmp	 $LN2@main
$LN3@main:
$LN11@main:
$LN9@main:

; 623  : 		}
; 624  : 		else
; 625  : 		{
; 626  : 			//log
; 627  : 		}
; 628  : 	}
; 629  : 	else
; 630  : 	{
; 631  : 		//log
; 632  : 	}
; 633  : 
; 634  : }

  006d5	33 c0		 xor	 eax, eax
  006d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006da	33 cd		 xor	 ecx, ebp
  006dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006e1	8b e5		 mov	 esp, ebp
  006e3	5d		 pop	 ebp
  006e4	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_dimensions$1 = -120					; size = 8
$T2 = -112						; size = 8
_DeviceContext$3 = -104					; size = 4
_AltKeyDown$4 = -100					; size = 4
_result$ = -96						; size = 4
_wasDown$5 = -92					; size = 4
_isDown$6 = -88						; size = 4
tv73 = -84						; size = 4
tv70 = -80						; size = 4
tv64 = -76						; size = 4
_VKCode$7 = -72						; size = 4
_Paint$8 = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_Window$ = 8						; size = 4
_Message$ = 12						; size = 4
_WParam$ = 16						; size = 4
_LParam$ = 20						; size = 4
?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z PROC	; Win32MainWindowCallback

; 322  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 323  : 	LRESULT result = 0;

  00010	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 324  : 
; 325  : 	switch (Message)

  00017	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  0001a	89 45 b4	 mov	 DWORD PTR tv64[ebp], eax
  0001d	81 7d b4 00 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 256 ; 00000100H
  00024	77 31		 ja	 SHORT $LN46@Win32MainW
  00026	81 7d b4 00 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 256 ; 00000100H
  0002d	0f 84 88 00 00
	00		 je	 $LN10@Win32MainW
  00033	8b 4d b4	 mov	 ecx, DWORD PTR tv64[ebp]
  00036	83 e9 02	 sub	 ecx, 2
  00039	89 4d b4	 mov	 DWORD PTR tv64[ebp], ecx
  0003c	83 7d b4 1a	 cmp	 DWORD PTR tv64[ebp], 26	; 0000001aH
  00040	0f 87 81 01 00
	00		 ja	 $LN40@Win32MainW
  00046	8b 55 b4	 mov	 edx, DWORD PTR tv64[ebp]
  00049	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN47@Win32MainW[edx]
  00050	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN48@Win32MainW[eax*4]
$LN46@Win32MainW:
  00057	81 7d b4 01 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 257 ; 00000101H
  0005e	74 5b		 je	 SHORT $LN10@Win32MainW
  00060	81 7d b4 04 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 260 ; 00000104H
  00067	74 52		 je	 SHORT $LN10@Win32MainW
  00069	81 7d b4 05 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 261 ; 00000105H
  00070	74 49		 je	 SHORT $LN10@Win32MainW
  00072	e9 50 01 00 00	 jmp	 $LN40@Win32MainW
$LN4@Win32MainW:

; 326  : 	{
; 327  : 	case WM_CLOSE:
; 328  : 	{
; 329  : 		g_running = false;

  00077	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_running@@3HA, 0

; 330  : 		OutputDebugStringA("WM_CLOSE\n");

  00081	68 00 00 00 00	 push	 OFFSET $SG98393
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 331  : 	} break;

  0008c	e9 4f 01 00 00	 jmp	 $LN2@Win32MainW
$LN5@Win32MainW:

; 332  : 	case WM_ACTIVATEAPP:
; 333  : 	{
; 334  : 		OutputDebugStringA("WM_ACTIVATEAPP\n");

  00091	68 00 00 00 00	 push	 OFFSET $SG98395
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 335  : 	} break;

  0009c	e9 3f 01 00 00	 jmp	 $LN2@Win32MainW
$LN6@Win32MainW:

; 336  : 	case WM_DESTROY:
; 337  : 	{
; 338  : 		g_running = false;

  000a1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_running@@3HA, 0

; 339  : 		OutputDebugStringA("WM_DESTROY\n");

  000ab	68 00 00 00 00	 push	 OFFSET $SG98397
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 340  : 	} break;

  000b6	e9 25 01 00 00	 jmp	 $LN2@Win32MainW
$LN10@Win32MainW:

; 341  : 
; 342  : 	case WM_SYSKEYDOWN:
; 343  : 	case WM_SYSKEYUP:
; 344  : 	case WM_KEYDOWN:
; 345  : 	case WM_KEYUP:
; 346  : 	{
; 347  : 		uint32 VKCode = WParam;

  000bb	8b 4d 10	 mov	 ecx, DWORD PTR _WParam$[ebp]
  000be	89 4d b8	 mov	 DWORD PTR _VKCode$7[ebp], ecx

; 348  : 		bool32 wasDown = ((LParam & (1 << 30)) != 0);

  000c1	8b 55 14	 mov	 edx, DWORD PTR _LParam$[ebp]
  000c4	81 e2 00 00 00
	40		 and	 edx, 1073741824		; 40000000H
  000ca	74 09		 je	 SHORT $LN42@Win32MainW
  000cc	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  000d3	eb 07		 jmp	 SHORT $LN43@Win32MainW
$LN42@Win32MainW:
  000d5	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN43@Win32MainW:
  000dc	8b 45 b0	 mov	 eax, DWORD PTR tv70[ebp]
  000df	89 45 a4	 mov	 DWORD PTR _wasDown$5[ebp], eax

; 349  : 		bool32 isDown = ((LParam & (1 << 31)) == 0);

  000e2	8b 4d 14	 mov	 ecx, DWORD PTR _LParam$[ebp]
  000e5	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  000eb	75 09		 jne	 SHORT $LN44@Win32MainW
  000ed	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  000f4	eb 07		 jmp	 SHORT $LN45@Win32MainW
$LN44@Win32MainW:
  000f6	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN45@Win32MainW:
  000fd	8b 55 ac	 mov	 edx, DWORD PTR tv73[ebp]
  00100	89 55 a8	 mov	 DWORD PTR _isDown$6[ebp], edx

; 350  : 		if (wasDown != isDown)

  00103	8b 45 a4	 mov	 eax, DWORD PTR _wasDown$5[ebp]
  00106	3b 45 a8	 cmp	 eax, DWORD PTR _isDown$6[ebp]
  00109	74 40		 je	 SHORT $LN11@Win32MainW

; 351  : 		{
; 352  : 			if (VKCode == 'W')

  0010b	83 7d b8 57	 cmp	 DWORD PTR _VKCode$7[ebp], 87 ; 00000057H
  0010f	75 3a		 jne	 SHORT $LN11@Win32MainW

; 353  : 			{
; 354  : 				OutputDebugStringA("W: ");

  00111	68 00 00 00 00	 push	 OFFSET $SG98405
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 355  : 				if (isDown)

  0011c	83 7d a8 00	 cmp	 DWORD PTR _isDown$6[ebp], 0
  00120	74 0d		 je	 SHORT $LN14@Win32MainW

; 356  : 				{
; 357  : 					OutputDebugStringA("isDown ");

  00122	68 00 00 00 00	 push	 OFFSET $SG98408
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 358  : 				}

  0012d	eb 11		 jmp	 SHORT $LN15@Win32MainW
$LN14@Win32MainW:

; 359  : 				else if (wasDown)

  0012f	83 7d a4 00	 cmp	 DWORD PTR _wasDown$5[ebp], 0
  00133	74 0b		 je	 SHORT $LN15@Win32MainW

; 360  : 				{
; 361  : 					OutputDebugStringA("wasDown ");

  00135	68 00 00 00 00	 push	 OFFSET $SG98410
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
$LN15@Win32MainW:

; 362  : 				}
; 363  : 				OutputDebugStringA("\n");

  00140	68 00 00 00 00	 push	 OFFSET $SG98411
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
$LN11@Win32MainW:

; 364  : 			}
; 365  : 			else if (VKCode == 'A')
; 366  : 			{
; 367  : 			}
; 368  : 			else if (VKCode == 'S')
; 369  : 			{
; 370  : 			}
; 371  : 			else if (VKCode == 'D')
; 372  : 			{
; 373  : 			}
; 374  : 			else if (VKCode == 'Q')
; 375  : 			{
; 376  : 			}
; 377  : 			else if (VKCode == 'E')
; 378  : 			{
; 379  : 			}
; 380  : 			else if (VKCode == VK_UP)
; 381  : 			{
; 382  : 			}
; 383  : 			else if (VKCode == VK_LEFT)
; 384  : 			{
; 385  : 			}
; 386  : 			else if (VKCode == VK_DOWN)
; 387  : 			{
; 388  : 			}
; 389  : 			else if (VKCode == VK_RIGHT)
; 390  : 			{
; 391  : 			}
; 392  : 			else if (VKCode == VK_ESCAPE)
; 393  : 			{
; 394  : 			}
; 395  : 			else if (VKCode == VK_SPACE)
; 396  : 			{
; 397  : 			}
; 398  : 		}
; 399  : 
; 400  : 		bool32 AltKeyDown = (LParam & (1 << 29));

  0014b	8b 4d 14	 mov	 ecx, DWORD PTR _LParam$[ebp]
  0014e	81 e1 00 00 00
	20		 and	 ecx, 536870912		; 20000000H
  00154	89 4d 9c	 mov	 DWORD PTR _AltKeyDown$4[ebp], ecx

; 401  : 		if ((VKCode == VK_F4) && AltKeyDown)

  00157	83 7d b8 73	 cmp	 DWORD PTR _VKCode$7[ebp], 115 ; 00000073H
  0015b	75 10		 jne	 SHORT $LN38@Win32MainW
  0015d	83 7d 9c 00	 cmp	 DWORD PTR _AltKeyDown$4[ebp], 0
  00161	74 0a		 je	 SHORT $LN38@Win32MainW

; 402  : 		{
; 403  : 			g_running = false;

  00163	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_running@@3HA, 0
$LN38@Win32MainW:

; 404  : 		}
; 405  : 
; 406  : 	} break;

  0016d	eb 71		 jmp	 SHORT $LN2@Win32MainW
$LN39@Win32MainW:

; 407  : 
; 408  : 	case WM_PAINT:
; 409  : 	{
; 410  : 		PAINTSTRUCT Paint;
; 411  : 		HDC DeviceContext = BeginPaint(Window, &Paint);

  0016f	8d 55 bc	 lea	 edx, DWORD PTR _Paint$8[ebp]
  00172	52		 push	 edx
  00173	8b 45 08	 mov	 eax, DWORD PTR _Window$[ebp]
  00176	50		 push	 eax
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BeginPaint@8
  0017d	89 45 98	 mov	 DWORD PTR _DeviceContext$3[ebp], eax

; 412  : 		win32_window_dimensions dimensions = Win32GetWindowDimensions(Window);

  00180	8b 4d 08	 mov	 ecx, DWORD PTR _Window$[ebp]
  00183	51		 push	 ecx
  00184	e8 00 00 00 00	 call	 ?Win32GetWindowDimensions@@YA?AUwin32_window_dimensions@@PAUHWND__@@@Z ; Win32GetWindowDimensions
  00189	83 c4 04	 add	 esp, 4
  0018c	89 45 90	 mov	 DWORD PTR $T2[ebp], eax
  0018f	89 55 94	 mov	 DWORD PTR $T2[ebp+4], edx
  00192	8b 55 90	 mov	 edx, DWORD PTR $T2[ebp]
  00195	8b 45 94	 mov	 eax, DWORD PTR $T2[ebp+4]
  00198	89 55 88	 mov	 DWORD PTR _dimensions$1[ebp], edx
  0019b	89 45 8c	 mov	 DWORD PTR _dimensions$1[ebp+4], eax

; 413  : 
; 414  : 		Win32DisplayBufferToWindow(

  0019e	8b 4d 8c	 mov	 ecx, DWORD PTR _dimensions$1[ebp+4]
  001a1	51		 push	 ecx
  001a2	8b 55 88	 mov	 edx, DWORD PTR _dimensions$1[ebp]
  001a5	52		 push	 edx
  001a6	8b 45 98	 mov	 eax, DWORD PTR _DeviceContext$3[ebp]
  001a9	50		 push	 eax
  001aa	68 00 00 00 00	 push	 OFFSET ?g_back_buffer@@3Uwin32_offscreen_buffer@@A
  001af	e8 00 00 00 00	 call	 ?Win32DisplayBufferToWindow@@YAXPAUwin32_offscreen_buffer@@PAUHDC__@@HH@Z ; Win32DisplayBufferToWindow
  001b4	83 c4 10	 add	 esp, 16			; 00000010H

; 415  : 			&g_back_buffer,
; 416  : 			DeviceContext,
; 417  : 			dimensions.width, dimensions.height);
; 418  : 		EndPaint(Window, &Paint);

  001b7	8d 4d bc	 lea	 ecx, DWORD PTR _Paint$8[ebp]
  001ba	51		 push	 ecx
  001bb	8b 55 08	 mov	 edx, DWORD PTR _Window$[ebp]
  001be	52		 push	 edx
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndPaint@8

; 419  : 	} break;

  001c5	eb 19		 jmp	 SHORT $LN2@Win32MainW
$LN40@Win32MainW:

; 420  : 
; 421  : 	default:
; 422  : 	{
; 423  : 		result = DefWindowProcA(Window, Message, WParam, LParam);

  001c7	8b 45 14	 mov	 eax, DWORD PTR _LParam$[ebp]
  001ca	50		 push	 eax
  001cb	8b 4d 10	 mov	 ecx, DWORD PTR _WParam$[ebp]
  001ce	51		 push	 ecx
  001cf	8b 55 0c	 mov	 edx, DWORD PTR _Message$[ebp]
  001d2	52		 push	 edx
  001d3	8b 45 08	 mov	 eax, DWORD PTR _Window$[ebp]
  001d6	50		 push	 eax
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  001dd	89 45 a0	 mov	 DWORD PTR _result$[ebp], eax
$LN2@Win32MainW:

; 424  : 	} break;
; 425  : 	}
; 426  : 
; 427  : 	return(result);

  001e0	8b 45 a0	 mov	 eax, DWORD PTR _result$[ebp]

; 428  : }

  001e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e6	33 cd		 xor	 ecx, ebp
  001e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ed	8b e5		 mov	 esp, ebp
  001ef	5d		 pop	 ebp
  001f0	c2 10 00	 ret	 16			; 00000010H
  001f3	90		 npad	 1
$LN48@Win32MainW:
  001f4	00 00 00 00	 DD	 $LN6@Win32MainW
  001f8	00 00 00 00	 DD	 $LN39@Win32MainW
  001fc	00 00 00 00	 DD	 $LN4@Win32MainW
  00200	00 00 00 00	 DD	 $LN5@Win32MainW
  00204	00 00 00 00	 DD	 $LN40@Win32MainW
$LN47@Win32MainW:
  00208	00		 DB	 0
  00209	04		 DB	 4
  0020a	04		 DB	 4
  0020b	04		 DB	 4
  0020c	04		 DB	 4
  0020d	04		 DB	 4
  0020e	04		 DB	 4
  0020f	04		 DB	 4
  00210	04		 DB	 4
  00211	04		 DB	 4
  00212	04		 DB	 4
  00213	04		 DB	 4
  00214	04		 DB	 4
  00215	01		 DB	 1
  00216	02		 DB	 2
  00217	04		 DB	 4
  00218	04		 DB	 4
  00219	04		 DB	 4
  0021a	04		 DB	 4
  0021b	04		 DB	 4
  0021c	04		 DB	 4
  0021d	04		 DB	 4
  0021e	04		 DB	 4
  0021f	04		 DB	 4
  00220	04		 DB	 4
  00221	04		 DB	 4
  00222	03		 DB	 3
?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z ENDP	; Win32MainWindowCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_DeviceContext$ = 12					; size = 4
_windowWidth$ = 16					; size = 4
_windowHeight$ = 20					; size = 4
?Win32DisplayBufferToWindow@@YAXPAUwin32_offscreen_buffer@@PAUHDC__@@HH@Z PROC ; Win32DisplayBufferToWindow

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 305  : 	StretchDIBits(

  00003	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  00008	6a 00		 push	 0
  0000a	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00011	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00018	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0001f	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00022	50		 push	 eax
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	8b 4d 14	 mov	 ecx, DWORD PTR _windowHeight$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 10	 mov	 edx, DWORD PTR _windowWidth$[ebp]
  0002e	52		 push	 edx
  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	8b 45 0c	 mov	 eax, DWORD PTR _DeviceContext$[ebp]
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52

; 306  : 		DeviceContext,
; 307  : 		/* dest: x, y, width, height,
; 308  : 		   src:	 x, y, width, height,*/
; 309  : 		0, 0, windowWidth, windowHeight,
; 310  : 		0, 0, buffer->width, buffer->height,
; 311  : 		buffer->memory,
; 312  : 		&buffer->info,
; 313  : 		DIB_RGB_COLORS,
; 314  : 		SRCCOPY);
; 315  : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?Win32DisplayBufferToWindow@@YAXPAUwin32_offscreen_buffer@@PAUHDC__@@HH@Z ENDP ; Win32DisplayBufferToWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_bitmapMemorySize$ = -8					; size = 4
_bytesPerPixel$ = -4					; size = 4
_buffer$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
?Win32ResizeDIBSection@@YAXPAUwin32_offscreen_buffer@@HH@Z PROC ; Win32ResizeDIBSection

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 277  : 	if (buffer->memory)

  00006	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00009	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0000d	74 14		 je	 SHORT $LN2@Win32Resiz

; 278  : 	{
; 279  : 		VirtualFree(buffer->memory, 0, MEM_RELEASE);

  0000f	68 00 80 00 00	 push	 32768			; 00008000H
  00014	6a 00		 push	 0
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00019	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0001c	52		 push	 edx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualFree@12
$LN2@Win32Resiz:

; 280  : 	}
; 281  : 
; 282  : 	buffer->width = width;

  00023	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _width$[ebp]
  00029	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 283  : 	buffer->height = height;

  0002c	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0002f	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  00032	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 284  : 	int bytesPerPixel = 4;

  00035	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR _bytesPerPixel$[ebp], 4

; 285  : 
; 286  : 	buffer->info.bmiHeader.biSize = sizeof(buffer->info.bmiHeader);

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0003f	c7 01 28 00 00
	00		 mov	 DWORD PTR [ecx], 40	; 00000028H

; 287  : 	buffer->info.bmiHeader.biWidth = buffer->width;

  00045	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00048	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0004b	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0004e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 288  : 	buffer->info.bmiHeader.biHeight = -buffer->height;

  00051	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00054	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00057	f7 d8		 neg	 eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0005c	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 289  : 	buffer->info.bmiHeader.biPlanes = 1;

  0005f	ba 01 00 00 00	 mov	 edx, 1
  00064	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00067	66 89 50 0c	 mov	 WORD PTR [eax+12], dx

; 290  : 	buffer->info.bmiHeader.biBitCount = 32;

  0006b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00070	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00073	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx

; 291  : 	buffer->info.bmiHeader.biCompression = BI_RGB;

  00077	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0007a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 292  : 
; 293  : 	int bitmapMemorySize = (buffer->width * buffer->height) * bytesPerPixel;

  00081	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00084	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00087	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0008a	0f af 42 34	 imul	 eax, DWORD PTR [edx+52]
  0008e	0f af 45 fc	 imul	 eax, DWORD PTR _bytesPerPixel$[ebp]
  00092	89 45 f8	 mov	 DWORD PTR _bitmapMemorySize$[ebp], eax

; 294  : 	buffer->memory = VirtualAlloc(0, bitmapMemorySize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

  00095	6a 04		 push	 4
  00097	68 00 30 00 00	 push	 12288			; 00003000H
  0009c	8b 4d f8	 mov	 ecx, DWORD PTR _bitmapMemorySize$[ebp]
  0009f	51		 push	 ecx
  000a0	6a 00		 push	 0
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
  000a8	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  000ab	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 295  : 	buffer->pitch = width * bytesPerPixel;

  000ae	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  000b1	0f af 45 fc	 imul	 eax, DWORD PTR _bytesPerPixel$[ebp]
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000b8	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 296  : 
; 297  : }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
?Win32ResizeDIBSection@@YAXPAUwin32_offscreen_buffer@@HH@Z ENDP ; Win32ResizeDIBSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_result$ = -28						; size = 8
_ClientRect$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_Window$ = 8						; size = 4
?Win32GetWindowDimensions@@YA?AUwin32_window_dimensions@@PAUHWND__@@@Z PROC ; Win32GetWindowDimensions

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 265  : 	win32_window_dimensions result;
; 266  : 
; 267  : 	RECT ClientRect;
; 268  : 	GetClientRect(Window, &ClientRect);

  00010	8d 45 ec	 lea	 eax, DWORD PTR _ClientRect$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _Window$[ebp]
  00017	51		 push	 ecx
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 269  : 	result.width = ClientRect.right - ClientRect.left;

  0001e	8b 55 f4	 mov	 edx, DWORD PTR _ClientRect$[ebp+8]
  00021	2b 55 ec	 sub	 edx, DWORD PTR _ClientRect$[ebp]
  00024	89 55 e4	 mov	 DWORD PTR _result$[ebp], edx

; 270  : 	result.height = ClientRect.bottom - ClientRect.top;

  00027	8b 45 f8	 mov	 eax, DWORD PTR _ClientRect$[ebp+12]
  0002a	2b 45 f0	 sub	 eax, DWORD PTR _ClientRect$[ebp+4]
  0002d	89 45 e8	 mov	 DWORD PTR _result$[ebp+4], eax

; 271  : 
; 272  : 	return(result);

  00030	8b 45 e4	 mov	 eax, DWORD PTR _result$[ebp]
  00033	8b 55 e8	 mov	 edx, DWORD PTR _result$[ebp+4]

; 273  : }

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00039	33 cd		 xor	 ecx, ebp
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?Win32GetWindowDimensions@@YA?AUwin32_window_dimensions@@PAUHWND__@@@Z ENDP ; Win32GetWindowDimensions
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_sineValue$1 = -56					; size = 4
_region2SampleCount$2 = -52				; size = 4
_sineValue$3 = -48					; size = 4
_region1SampleCount$4 = -44				; size = 4
_Region1$ = -40						; size = 4
_Region1Size$ = -36					; size = 4
_Region2$ = -32						; size = 4
_Region2Size$ = -28					; size = 4
_SampleIndex$5 = -24					; size = 4
_SampleIndex$6 = -20					; size = 4
_srcSample$7 = -16					; size = 4
_destSample$8 = -12					; size = 4
_sampleValue$9 = -8					; size = 2
_sampleValue$10 = -4					; size = 2
_soundOutput$ = 8					; size = 4
_sourceBuffer$ = 12					; size = 4
_byteToLock$ = 16					; size = 4
_bytesToWrite$ = 20					; size = 4
?Win32FillSoundBuffer@@YAXPAUwin32_sound_output@@PAUgame_sound_output_buffer@@KK@Z PROC ; Win32FillSoundBuffer

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H

; 223  : 	VOID* Region1;
; 224  : 	DWORD Region1Size;
; 225  : 	VOID* Region2;
; 226  : 	DWORD Region2Size;
; 227  : 
; 228  : 	if (SUCCEEDED(g_secondary_buffer->Lock(

  00006	6a 00		 push	 0
  00008	8d 45 e4	 lea	 eax, DWORD PTR _Region2Size$[ebp]
  0000b	50		 push	 eax
  0000c	8d 4d e0	 lea	 ecx, DWORD PTR _Region2$[ebp]
  0000f	51		 push	 ecx
  00010	8d 55 dc	 lea	 edx, DWORD PTR _Region1Size$[ebp]
  00013	52		 push	 edx
  00014	8d 45 d8	 lea	 eax, DWORD PTR _Region1$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 14	 mov	 ecx, DWORD PTR _bytesToWrite$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 10	 mov	 edx, DWORD PTR _byteToLock$[ebp]
  0001f	52		 push	 edx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  0002d	52		 push	 edx
  0002e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00031	ff d0		 call	 eax
  00033	85 c0		 test	 eax, eax
  00035	0f 8c 93 01 00
	00		 jl	 $LN8@Win32FillS

; 229  : 		byteToLock, bytesToWrite,
; 230  : 		&Region1, &Region1Size,
; 231  : 		&Region2, &Region2Size,
; 232  : 		0)))
; 233  : 	{
; 234  : 		DWORD region1SampleCount = Region1Size / soundOutput->bytesPerSample;

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _soundOutput$[ebp]
  0003e	8b 45 dc	 mov	 eax, DWORD PTR _Region1Size$[ebp]
  00041	33 d2		 xor	 edx, edx
  00043	f7 71 14	 div	 DWORD PTR [ecx+20]
  00046	89 45 d4	 mov	 DWORD PTR _region1SampleCount$4[ebp], eax

; 235  : 		int16* destSample = (int16*)Region1;

  00049	8b 55 d8	 mov	 edx, DWORD PTR _Region1$[ebp]
  0004c	89 55 f4	 mov	 DWORD PTR _destSample$8[ebp], edx

; 236  : 		int16* srcSample = sourceBuffer->samples;

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _sourceBuffer$[ebp]
  00052	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00055	89 4d f0	 mov	 DWORD PTR _srcSample$7[ebp], ecx

; 237  : 		for (DWORD SampleIndex = 0; SampleIndex < region1SampleCount; ++SampleIndex)

  00058	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _SampleIndex$6[ebp], 0
  0005f	eb 09		 jmp	 SHORT $LN4@Win32FillS
$LN2@Win32FillS:
  00061	8b 55 ec	 mov	 edx, DWORD PTR _SampleIndex$6[ebp]
  00064	83 c2 01	 add	 edx, 1
  00067	89 55 ec	 mov	 DWORD PTR _SampleIndex$6[ebp], edx
$LN4@Win32FillS:
  0006a	8b 45 ec	 mov	 eax, DWORD PTR _SampleIndex$6[ebp]
  0006d	3b 45 d4	 cmp	 eax, DWORD PTR _region1SampleCount$4[ebp]
  00070	0f 83 81 00 00
	00		 jae	 $LN3@Win32FillS

; 238  : 		{
; 239  : 			real32 sineValue = sinf(soundOutput->tSine);

  00076	8b 4d 08	 mov	 ecx, DWORD PTR _soundOutput$[ebp]
  00079	51		 push	 ecx
  0007a	f3 0f 10 41 1c	 movss	 xmm0, DWORD PTR [ecx+28]
  0007f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00084	e8 00 00 00 00	 call	 _sinf
  00089	83 c4 04	 add	 esp, 4
  0008c	d9 5d d0	 fstp	 DWORD PTR _sineValue$3[ebp]

; 240  : 			int16 sampleValue = (int16)(sineValue * soundOutput->toneVolume);

  0008f	8b 55 08	 mov	 edx, DWORD PTR _soundOutput$[ebp]
  00092	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  00096	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0009a	f3 0f 59 45 d0	 mulss	 xmm0, DWORD PTR _sineValue$3[ebp]
  0009f	f3 0f 2c c8	 cvttss2si ecx, xmm0
  000a3	66 89 4d fc	 mov	 WORD PTR _sampleValue$10[ebp], cx

; 241  : 			*destSample++ = *srcSample++;

  000a7	8b 55 f4	 mov	 edx, DWORD PTR _destSample$8[ebp]
  000aa	8b 45 f0	 mov	 eax, DWORD PTR _srcSample$7[ebp]
  000ad	66 8b 08	 mov	 cx, WORD PTR [eax]
  000b0	66 89 0a	 mov	 WORD PTR [edx], cx
  000b3	8b 55 f4	 mov	 edx, DWORD PTR _destSample$8[ebp]
  000b6	83 c2 02	 add	 edx, 2
  000b9	89 55 f4	 mov	 DWORD PTR _destSample$8[ebp], edx
  000bc	8b 45 f0	 mov	 eax, DWORD PTR _srcSample$7[ebp]
  000bf	83 c0 02	 add	 eax, 2
  000c2	89 45 f0	 mov	 DWORD PTR _srcSample$7[ebp], eax

; 242  : 			*destSample++ = *srcSample++;

  000c5	8b 4d f4	 mov	 ecx, DWORD PTR _destSample$8[ebp]
  000c8	8b 55 f0	 mov	 edx, DWORD PTR _srcSample$7[ebp]
  000cb	66 8b 02	 mov	 ax, WORD PTR [edx]
  000ce	66 89 01	 mov	 WORD PTR [ecx], ax
  000d1	8b 4d f4	 mov	 ecx, DWORD PTR _destSample$8[ebp]
  000d4	83 c1 02	 add	 ecx, 2
  000d7	89 4d f4	 mov	 DWORD PTR _destSample$8[ebp], ecx
  000da	8b 55 f0	 mov	 edx, DWORD PTR _srcSample$7[ebp]
  000dd	83 c2 02	 add	 edx, 2
  000e0	89 55 f0	 mov	 DWORD PTR _srcSample$7[ebp], edx

; 243  : 			++soundOutput->runningSampleIndex;

  000e3	8b 45 08	 mov	 eax, DWORD PTR _soundOutput$[ebp]
  000e6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000e9	83 c1 01	 add	 ecx, 1
  000ec	8b 55 08	 mov	 edx, DWORD PTR _soundOutput$[ebp]
  000ef	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 244  : 		}

  000f2	e9 6a ff ff ff	 jmp	 $LN2@Win32FillS
$LN3@Win32FillS:

; 245  : 
; 246  : 		DWORD region2SampleCount = Region2Size / soundOutput->bytesPerSample;

  000f7	8b 4d 08	 mov	 ecx, DWORD PTR _soundOutput$[ebp]
  000fa	8b 45 e4	 mov	 eax, DWORD PTR _Region2Size$[ebp]
  000fd	33 d2		 xor	 edx, edx
  000ff	f7 71 14	 div	 DWORD PTR [ecx+20]
  00102	89 45 cc	 mov	 DWORD PTR _region2SampleCount$2[ebp], eax

; 247  : 		destSample = (int16*)Region2;

  00105	8b 55 e0	 mov	 edx, DWORD PTR _Region2$[ebp]
  00108	89 55 f4	 mov	 DWORD PTR _destSample$8[ebp], edx

; 248  : 		for (DWORD SampleIndex = 0; SampleIndex < region2SampleCount; ++SampleIndex)

  0010b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SampleIndex$5[ebp], 0
  00112	eb 09		 jmp	 SHORT $LN7@Win32FillS
$LN5@Win32FillS:
  00114	8b 45 e8	 mov	 eax, DWORD PTR _SampleIndex$5[ebp]
  00117	83 c0 01	 add	 eax, 1
  0011a	89 45 e8	 mov	 DWORD PTR _SampleIndex$5[ebp], eax
$LN7@Win32FillS:
  0011d	8b 4d e8	 mov	 ecx, DWORD PTR _SampleIndex$5[ebp]
  00120	3b 4d cc	 cmp	 ecx, DWORD PTR _region2SampleCount$2[ebp]
  00123	0f 83 81 00 00
	00		 jae	 $LN6@Win32FillS

; 249  : 		{
; 250  : 			real32 sineValue = sinf(soundOutput->tSine);

  00129	8b 55 08	 mov	 edx, DWORD PTR _soundOutput$[ebp]
  0012c	51		 push	 ecx
  0012d	f3 0f 10 42 1c	 movss	 xmm0, DWORD PTR [edx+28]
  00132	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00137	e8 00 00 00 00	 call	 _sinf
  0013c	83 c4 04	 add	 esp, 4
  0013f	d9 5d c8	 fstp	 DWORD PTR _sineValue$1[ebp]

; 251  : 			int16 sampleValue = (int16)(sineValue * soundOutput->toneVolume);

  00142	8b 45 08	 mov	 eax, DWORD PTR _soundOutput$[ebp]
  00145	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00149	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0014d	f3 0f 59 45 c8	 mulss	 xmm0, DWORD PTR _sineValue$1[ebp]
  00152	f3 0f 2c d0	 cvttss2si edx, xmm0
  00156	66 89 55 f8	 mov	 WORD PTR _sampleValue$9[ebp], dx

; 252  : 			*destSample++ = *srcSample++;

  0015a	8b 45 f4	 mov	 eax, DWORD PTR _destSample$8[ebp]
  0015d	8b 4d f0	 mov	 ecx, DWORD PTR _srcSample$7[ebp]
  00160	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00163	66 89 10	 mov	 WORD PTR [eax], dx
  00166	8b 45 f4	 mov	 eax, DWORD PTR _destSample$8[ebp]
  00169	83 c0 02	 add	 eax, 2
  0016c	89 45 f4	 mov	 DWORD PTR _destSample$8[ebp], eax
  0016f	8b 4d f0	 mov	 ecx, DWORD PTR _srcSample$7[ebp]
  00172	83 c1 02	 add	 ecx, 2
  00175	89 4d f0	 mov	 DWORD PTR _srcSample$7[ebp], ecx

; 253  : 			*destSample++ = *srcSample++;

  00178	8b 55 f4	 mov	 edx, DWORD PTR _destSample$8[ebp]
  0017b	8b 45 f0	 mov	 eax, DWORD PTR _srcSample$7[ebp]
  0017e	66 8b 08	 mov	 cx, WORD PTR [eax]
  00181	66 89 0a	 mov	 WORD PTR [edx], cx
  00184	8b 55 f4	 mov	 edx, DWORD PTR _destSample$8[ebp]
  00187	83 c2 02	 add	 edx, 2
  0018a	89 55 f4	 mov	 DWORD PTR _destSample$8[ebp], edx
  0018d	8b 45 f0	 mov	 eax, DWORD PTR _srcSample$7[ebp]
  00190	83 c0 02	 add	 eax, 2
  00193	89 45 f0	 mov	 DWORD PTR _srcSample$7[ebp], eax

; 254  : 			++soundOutput->runningSampleIndex;

  00196	8b 4d 08	 mov	 ecx, DWORD PTR _soundOutput$[ebp]
  00199	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0019c	83 c2 01	 add	 edx, 1
  0019f	8b 45 08	 mov	 eax, DWORD PTR _soundOutput$[ebp]
  001a2	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 255  : 		}

  001a5	e9 6a ff ff ff	 jmp	 $LN5@Win32FillS
$LN6@Win32FillS:

; 256  : 
; 257  : 		g_secondary_buffer->Unlock(

  001aa	8b 4d e4	 mov	 ecx, DWORD PTR _Region2Size$[ebp]
  001ad	51		 push	 ecx
  001ae	8b 55 e0	 mov	 edx, DWORD PTR _Region2$[ebp]
  001b1	52		 push	 edx
  001b2	8b 45 dc	 mov	 eax, DWORD PTR _Region1Size$[ebp]
  001b5	50		 push	 eax
  001b6	8b 4d d8	 mov	 ecx, DWORD PTR _Region1$[ebp]
  001b9	51		 push	 ecx
  001ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  001c0	8b 02		 mov	 eax, DWORD PTR [edx]
  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  001c8	51		 push	 ecx
  001c9	8b 50 4c	 mov	 edx, DWORD PTR [eax+76]
  001cc	ff d2		 call	 edx
$LN8@Win32FillS:

; 258  : 			Region1, Region1Size,
; 259  : 			Region2, Region2Size);
; 260  : 	}
; 261  : }

  001ce	8b e5		 mov	 esp, ebp
  001d0	5d		 pop	 ebp
  001d1	c3		 ret	 0
?Win32FillSoundBuffer@@YAXPAUwin32_sound_output@@PAUgame_sound_output_buffer@@KK@Z ENDP ; Win32FillSoundBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_Region1$ = -28						; size = 4
_Region1Size$ = -24					; size = 4
_Region2$ = -20						; size = 4
_Region2Size$ = -16					; size = 4
_byteIndex$1 = -12					; size = 4
_byteIndex$2 = -8					; size = 4
_destSample$3 = -4					; size = 4
_soundOutput$ = 8					; size = 4
?Win32ClearBuffer@@YAXPAUwin32_sound_output@@@Z PROC	; Win32ClearBuffer

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 191  : 	VOID* Region1;
; 192  : 	DWORD Region1Size;
; 193  : 	VOID* Region2;
; 194  : 	DWORD Region2Size;
; 195  : 	if (SUCCEEDED(g_secondary_buffer->Lock(

  00006	6a 00		 push	 0
  00008	8d 45 f0	 lea	 eax, DWORD PTR _Region2Size$[ebp]
  0000b	50		 push	 eax
  0000c	8d 4d ec	 lea	 ecx, DWORD PTR _Region2$[ebp]
  0000f	51		 push	 ecx
  00010	8d 55 e8	 lea	 edx, DWORD PTR _Region1Size$[ebp]
  00013	52		 push	 edx
  00014	8d 45 e4	 lea	 eax, DWORD PTR _Region1$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _soundOutput$[ebp]
  0001b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0001e	52		 push	 edx
  0001f	6a 00		 push	 0
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  0002e	52		 push	 edx
  0002f	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00032	ff d0		 call	 eax
  00034	85 c0		 test	 eax, eax
  00036	0f 8c 85 00 00
	00		 jl	 $LN1@Win32Clear

; 196  : 		0, soundOutput->bufferSize,
; 197  : 		&Region1, &Region1Size,
; 198  : 		&Region2, &Region2Size,
; 199  : 		0)))
; 200  : 	{
; 201  : 		uint8* destSample = (uint8*)Region1;

  0003c	8b 4d e4	 mov	 ecx, DWORD PTR _Region1$[ebp]
  0003f	89 4d fc	 mov	 DWORD PTR _destSample$3[ebp], ecx

; 202  : 		for (DWORD byteIndex = 0; byteIndex < Region1Size; ++byteIndex)

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _byteIndex$2[ebp], 0
  00049	eb 09		 jmp	 SHORT $LN4@Win32Clear
$LN2@Win32Clear:
  0004b	8b 55 f8	 mov	 edx, DWORD PTR _byteIndex$2[ebp]
  0004e	83 c2 01	 add	 edx, 1
  00051	89 55 f8	 mov	 DWORD PTR _byteIndex$2[ebp], edx
$LN4@Win32Clear:
  00054	8b 45 f8	 mov	 eax, DWORD PTR _byteIndex$2[ebp]
  00057	3b 45 e8	 cmp	 eax, DWORD PTR _Region1Size$[ebp]
  0005a	73 11		 jae	 SHORT $LN3@Win32Clear

; 203  : 		{
; 204  : 			*destSample++ = 0;

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _destSample$3[ebp]
  0005f	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00062	8b 55 fc	 mov	 edx, DWORD PTR _destSample$3[ebp]
  00065	83 c2 01	 add	 edx, 1
  00068	89 55 fc	 mov	 DWORD PTR _destSample$3[ebp], edx

; 205  : 		}

  0006b	eb de		 jmp	 SHORT $LN2@Win32Clear
$LN3@Win32Clear:

; 206  : 
; 207  : 		destSample = (uint8*)Region2;

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _Region2$[ebp]
  00070	89 45 fc	 mov	 DWORD PTR _destSample$3[ebp], eax

; 208  : 		for (DWORD byteIndex = 0; byteIndex < Region2Size; ++byteIndex)

  00073	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _byteIndex$1[ebp], 0
  0007a	eb 09		 jmp	 SHORT $LN7@Win32Clear
$LN5@Win32Clear:
  0007c	8b 4d f4	 mov	 ecx, DWORD PTR _byteIndex$1[ebp]
  0007f	83 c1 01	 add	 ecx, 1
  00082	89 4d f4	 mov	 DWORD PTR _byteIndex$1[ebp], ecx
$LN7@Win32Clear:
  00085	8b 55 f4	 mov	 edx, DWORD PTR _byteIndex$1[ebp]
  00088	3b 55 f0	 cmp	 edx, DWORD PTR _Region2Size$[ebp]
  0008b	73 11		 jae	 SHORT $LN6@Win32Clear

; 209  : 		{
; 210  : 			*destSample++ = 0;

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _destSample$3[ebp]
  00090	c6 00 00	 mov	 BYTE PTR [eax], 0
  00093	8b 4d fc	 mov	 ecx, DWORD PTR _destSample$3[ebp]
  00096	83 c1 01	 add	 ecx, 1
  00099	89 4d fc	 mov	 DWORD PTR _destSample$3[ebp], ecx

; 211  : 		}

  0009c	eb de		 jmp	 SHORT $LN5@Win32Clear
$LN6@Win32Clear:

; 212  : 
; 213  : 		g_secondary_buffer->Unlock(Region1, Region1Size, Region2, Region2Size);

  0009e	8b 55 f0	 mov	 edx, DWORD PTR _Region2Size$[ebp]
  000a1	52		 push	 edx
  000a2	8b 45 ec	 mov	 eax, DWORD PTR _Region2$[ebp]
  000a5	50		 push	 eax
  000a6	8b 4d e8	 mov	 ecx, DWORD PTR _Region1Size$[ebp]
  000a9	51		 push	 ecx
  000aa	8b 55 e4	 mov	 edx, DWORD PTR _Region1$[ebp]
  000ad	52		 push	 edx
  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  000bb	52		 push	 edx
  000bc	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  000bf	ff d0		 call	 eax
$LN1@Win32Clear:

; 214  : 	}
; 215  : }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?Win32ClearBuffer@@YAXPAUwin32_sound_output@@@Z ENDP	; Win32ClearBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_primaryBuffer$1 = -112					; size = 4
_DirectSoundCreate$2 = -108				; size = 4
_library$ = -104					; size = 4
_directSound$3 = -100					; size = 4
_bufferDescription$4 = -96				; size = 36
_bufferDescription$5 = -60				; size = 36
_waveFormat$6 = -24					; size = 18
__$ArrayPad$ = -4					; size = 4
_Window$ = 8						; size = 4
_samplesPerSecond$ = 12					; size = 4
_bufferSize$ = 16					; size = 4
?Win32InitDSound@@YAXPAUHWND__@@HH@Z PROC		; Win32InitDSound

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 119  : 	HMODULE library = LoadLibraryA("dsound.dll");

  00010	68 00 00 00 00	 push	 OFFSET $SG98287
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0001b	89 45 98	 mov	 DWORD PTR _library$[ebp], eax

; 120  : 	if (library)

  0001e	83 7d 98 00	 cmp	 DWORD PTR _library$[ebp], 0
  00022	0f 84 58 01 00
	00		 je	 $LN1@Win32InitD

; 121  : 	{
; 122  : 		direct_sound_create* DirectSoundCreate = (direct_sound_create*)GetProcAddress(library, "DirectSoundCreate");

  00028	68 00 00 00 00	 push	 OFFSET $SG98290
  0002d	8b 45 98	 mov	 eax, DWORD PTR _library$[ebp]
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00037	89 45 94	 mov	 DWORD PTR _DirectSoundCreate$2[ebp], eax

; 123  : 
; 124  : 		LPDIRECTSOUND directSound;
; 125  : 		if (DirectSoundCreate && SUCCEEDED(DirectSoundCreate(0, &directSound, 0)))

  0003a	83 7d 94 00	 cmp	 DWORD PTR _DirectSoundCreate$2[ebp], 0
  0003e	0f 84 3c 01 00
	00		 je	 $LN1@Win32InitD
  00044	6a 00		 push	 0
  00046	8d 4d 9c	 lea	 ecx, DWORD PTR _directSound$3[ebp]
  00049	51		 push	 ecx
  0004a	6a 00		 push	 0
  0004c	ff 55 94	 call	 DWORD PTR _DirectSoundCreate$2[ebp]
  0004f	85 c0		 test	 eax, eax
  00051	0f 8c 29 01 00
	00		 jl	 $LN1@Win32InitD

; 126  : 		{
; 127  : 			WAVEFORMATEX waveFormat;
; 128  : 			waveFormat.wFormatTag = WAVE_FORMAT_PCM;

  00057	ba 01 00 00 00	 mov	 edx, 1
  0005c	66 89 55 e8	 mov	 WORD PTR _waveFormat$6[ebp], dx

; 129  : 			waveFormat.nChannels = 2;

  00060	b8 02 00 00 00	 mov	 eax, 2
  00065	66 89 45 ea	 mov	 WORD PTR _waveFormat$6[ebp+2], ax

; 130  : 			waveFormat.nSamplesPerSec = samplesPerSecond;

  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _samplesPerSecond$[ebp]
  0006c	89 4d ec	 mov	 DWORD PTR _waveFormat$6[ebp+4], ecx

; 131  : 			waveFormat.wBitsPerSample = 16;

  0006f	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00074	66 89 55 f6	 mov	 WORD PTR _waveFormat$6[ebp+14], dx

; 132  : 			waveFormat.nBlockAlign = (waveFormat.nChannels * waveFormat.wBitsPerSample) / 8;

  00078	0f b7 45 ea	 movzx	 eax, WORD PTR _waveFormat$6[ebp+2]
  0007c	0f b7 4d f6	 movzx	 ecx, WORD PTR _waveFormat$6[ebp+14]
  00080	0f af c1	 imul	 eax, ecx
  00083	99		 cdq
  00084	83 e2 07	 and	 edx, 7
  00087	03 c2		 add	 eax, edx
  00089	c1 f8 03	 sar	 eax, 3
  0008c	66 89 45 f4	 mov	 WORD PTR _waveFormat$6[ebp+12], ax

; 133  : 			waveFormat.nAvgBytesPerSec = waveFormat.nSamplesPerSec * waveFormat.nBlockAlign;

  00090	0f b7 55 f4	 movzx	 edx, WORD PTR _waveFormat$6[ebp+12]
  00094	0f af 55 ec	 imul	 edx, DWORD PTR _waveFormat$6[ebp+4]
  00098	89 55 f0	 mov	 DWORD PTR _waveFormat$6[ebp+8], edx

; 134  : 			waveFormat.cbSize = 0;

  0009b	33 c0		 xor	 eax, eax
  0009d	66 89 45 f8	 mov	 WORD PTR _waveFormat$6[ebp+16], ax

; 135  : 
; 136  : 			if (SUCCEEDED(directSound->SetCooperativeLevel(Window, DSSCL_PRIORITY)))

  000a1	6a 02		 push	 2
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _Window$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 55 9c	 mov	 edx, DWORD PTR _directSound$3[ebp]
  000aa	8b 02		 mov	 eax, DWORD PTR [edx]
  000ac	8b 4d 9c	 mov	 ecx, DWORD PTR _directSound$3[ebp]
  000af	51		 push	 ecx
  000b0	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000b3	ff d2		 call	 edx
  000b5	85 c0		 test	 eax, eax
  000b7	7c 68		 jl	 SHORT $LN7@Win32InitD

; 137  : 			{
; 138  : 				DSBUFFERDESC bufferDescription = {};

  000b9	33 c0		 xor	 eax, eax
  000bb	89 45 c4	 mov	 DWORD PTR _bufferDescription$5[ebp], eax
  000be	89 45 c8	 mov	 DWORD PTR _bufferDescription$5[ebp+4], eax
  000c1	89 45 cc	 mov	 DWORD PTR _bufferDescription$5[ebp+8], eax
  000c4	89 45 d0	 mov	 DWORD PTR _bufferDescription$5[ebp+12], eax
  000c7	89 45 d4	 mov	 DWORD PTR _bufferDescription$5[ebp+16], eax
  000ca	89 45 d8	 mov	 DWORD PTR _bufferDescription$5[ebp+20], eax
  000cd	89 45 dc	 mov	 DWORD PTR _bufferDescription$5[ebp+24], eax
  000d0	89 45 e0	 mov	 DWORD PTR _bufferDescription$5[ebp+28], eax
  000d3	89 45 e4	 mov	 DWORD PTR _bufferDescription$5[ebp+32], eax

; 139  : 				bufferDescription.dwSize = sizeof(bufferDescription);

  000d6	c7 45 c4 24 00
	00 00		 mov	 DWORD PTR _bufferDescription$5[ebp], 36 ; 00000024H

; 140  : 				bufferDescription.dwFlags = DSBCAPS_PRIMARYBUFFER;

  000dd	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _bufferDescription$5[ebp+4], 1

; 141  : 				LPDIRECTSOUNDBUFFER primaryBuffer;
; 142  : 				if (SUCCEEDED(directSound->CreateSoundBuffer(&bufferDescription, &primaryBuffer, 0)))

  000e4	6a 00		 push	 0
  000e6	8d 4d 90	 lea	 ecx, DWORD PTR _primaryBuffer$1[ebp]
  000e9	51		 push	 ecx
  000ea	8d 55 c4	 lea	 edx, DWORD PTR _bufferDescription$5[ebp]
  000ed	52		 push	 edx
  000ee	8b 45 9c	 mov	 eax, DWORD PTR _directSound$3[ebp]
  000f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f3	8b 55 9c	 mov	 edx, DWORD PTR _directSound$3[ebp]
  000f6	52		 push	 edx
  000f7	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000fa	ff d0		 call	 eax
  000fc	85 c0		 test	 eax, eax
  000fe	7c 21		 jl	 SHORT $LN7@Win32InitD

; 143  : 				{
; 144  : 					if (SUCCEEDED(primaryBuffer->SetFormat(&waveFormat)))

  00100	8d 4d e8	 lea	 ecx, DWORD PTR _waveFormat$6[ebp]
  00103	51		 push	 ecx
  00104	8b 55 90	 mov	 edx, DWORD PTR _primaryBuffer$1[ebp]
  00107	8b 02		 mov	 eax, DWORD PTR [edx]
  00109	8b 4d 90	 mov	 ecx, DWORD PTR _primaryBuffer$1[ebp]
  0010c	51		 push	 ecx
  0010d	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  00110	ff d2		 call	 edx
  00112	85 c0		 test	 eax, eax
  00114	7c 0b		 jl	 SHORT $LN7@Win32InitD

; 145  : 					{
; 146  : 						OutputDebugStringA("Primary buffer format was set.\n");

  00116	68 00 00 00 00	 push	 OFFSET $SG98299
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
$LN7@Win32InitD:

; 147  : 					}
; 148  : 					else
; 149  : 					{
; 150  : 						// log diagnostic
; 151  : 					}
; 152  : 				}
; 153  : 				else
; 154  : 				{
; 155  : 					// log diagnostic
; 156  : 				}
; 157  : 			}
; 158  : 			else
; 159  : 			{
; 160  : 				// log diagnostic
; 161  : 			}
; 162  : 
; 163  : 			DSBUFFERDESC bufferDescription = {};

  00121	33 c0		 xor	 eax, eax
  00123	89 45 a0	 mov	 DWORD PTR _bufferDescription$4[ebp], eax
  00126	89 45 a4	 mov	 DWORD PTR _bufferDescription$4[ebp+4], eax
  00129	89 45 a8	 mov	 DWORD PTR _bufferDescription$4[ebp+8], eax
  0012c	89 45 ac	 mov	 DWORD PTR _bufferDescription$4[ebp+12], eax
  0012f	89 45 b0	 mov	 DWORD PTR _bufferDescription$4[ebp+16], eax
  00132	89 45 b4	 mov	 DWORD PTR _bufferDescription$4[ebp+20], eax
  00135	89 45 b8	 mov	 DWORD PTR _bufferDescription$4[ebp+24], eax
  00138	89 45 bc	 mov	 DWORD PTR _bufferDescription$4[ebp+28], eax
  0013b	89 45 c0	 mov	 DWORD PTR _bufferDescription$4[ebp+32], eax

; 164  : 			bufferDescription.dwSize = sizeof(bufferDescription);

  0013e	c7 45 a0 24 00
	00 00		 mov	 DWORD PTR _bufferDescription$4[ebp], 36 ; 00000024H

; 165  : 			bufferDescription.dwFlags = 0;

  00145	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _bufferDescription$4[ebp+4], 0

; 166  : 			bufferDescription.dwBufferBytes = bufferSize;

  0014c	8b 4d 10	 mov	 ecx, DWORD PTR _bufferSize$[ebp]
  0014f	89 4d a8	 mov	 DWORD PTR _bufferDescription$4[ebp+8], ecx

; 167  : 			bufferDescription.lpwfxFormat = &waveFormat;

  00152	8d 55 e8	 lea	 edx, DWORD PTR _waveFormat$6[ebp]
  00155	89 55 b0	 mov	 DWORD PTR _bufferDescription$4[ebp+16], edx

; 168  : 			if (SUCCEEDED(directSound->CreateSoundBuffer(&bufferDescription, &g_secondary_buffer, 0)))

  00158	6a 00		 push	 0
  0015a	68 00 00 00 00	 push	 OFFSET ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  0015f	8d 45 a0	 lea	 eax, DWORD PTR _bufferDescription$4[ebp]
  00162	50		 push	 eax
  00163	8b 4d 9c	 mov	 ecx, DWORD PTR _directSound$3[ebp]
  00166	8b 11		 mov	 edx, DWORD PTR [ecx]
  00168	8b 45 9c	 mov	 eax, DWORD PTR _directSound$3[ebp]
  0016b	50		 push	 eax
  0016c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0016f	ff d1		 call	 ecx
  00171	85 c0		 test	 eax, eax
  00173	7c 0b		 jl	 SHORT $LN1@Win32InitD

; 169  : 			{
; 170  : 				OutputDebugStringA("Primary buffer format was set.\n");

  00175	68 00 00 00 00	 push	 OFFSET $SG98302
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
$LN1@Win32InitD:

; 171  : 			}
; 172  : 			else
; 173  : 			{
; 174  : 				// log diagnostic
; 175  : 			}
; 176  : 		}
; 177  : 		else
; 178  : 		{
; 179  : 			// log diagnostic
; 180  : 		}
; 181  : 	}
; 182  : 	else
; 183  : 	{
; 184  : 		// log diagnostic
; 185  : 	}
; 186  : 
; 187  : }

  00180	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00183	33 cd		 xor	 ecx, ebp
  00185	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c3		 ret	 0
?Win32InitDSound@@YAXPAUHWND__@@HH@Z ENDP		; Win32InitDSound
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_library$ = -4						; size = 4
?Win32LoadXInput@@YAXXZ PROC				; Win32LoadXInput

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 95   : 	HMODULE library = LoadLibraryA("xinput1_4.dll");

  00004	68 00 00 00 00	 push	 OFFSET $SG98261
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0000f	89 45 fc	 mov	 DWORD PTR _library$[ebp], eax

; 96   : 	if (library)

  00012	83 7d fc 00	 cmp	 DWORD PTR _library$[ebp], 0
  00016	74 4e		 je	 SHORT $LN1@Win32LoadX

; 97   : 	{
; 98   : 		XInputGetState = (x_input_get_state*)GetProcAddress(library, "XInputGetState");

  00018	68 00 00 00 00	 push	 OFFSET $SG98264
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _library$[ebp]
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00027	a3 00 00 00 00	 mov	 DWORD PTR ?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA, eax

; 99   : 		if (!XInputGetState) {

  0002c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA, 0
  00033	75 0a		 jne	 SHORT $LN4@Win32LoadX

; 100  : 			XInputGetState = XInputGetStateStub;

  00035	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA, OFFSET ?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z ; XInputGetStateStub
$LN4@Win32LoadX:

; 101  : 		}
; 102  : 		xInputSetState_ = (x_input_set_state*)GetProcAddress(library, "XInputSetState");

  0003f	68 00 00 00 00	 push	 OFFSET $SG98266
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _library$[ebp]
  00047	51		 push	 ecx
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0004e	a3 00 00 00 00	 mov	 DWORD PTR ?xInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA, eax

; 103  : 		if (!XInputSetState) {

  00053	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?xInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA, 0
  0005a	75 0a		 jne	 SHORT $LN1@Win32LoadX

; 104  : 			XInputSetState = XInputSetStateStub;

  0005c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?xInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA, OFFSET ?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ; XInputSetStateStub
$LN1@Win32LoadX:

; 105  : 		}
; 106  : 		else
; 107  : 		{
; 108  : 			// log diagnostic
; 109  : 		}
; 110  : 	}
; 111  : 	else
; 112  : 	{
; 113  : 		// log diagnostic
; 114  : 	}
; 115  : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?Win32LoadXInput@@YAXXZ ENDP				; Win32LoadXInput
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_dwUserIndex$ = 8					; size = 4
_pVibration$ = 12					; size = 4
?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z PROC	; XInputSetStateStub

; 72   : XINPUT_SET_STATE(XInputSetStateStub) { return(ERROR_DEVICE_NOT_CONNECTED); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 8f 04 00 00	 mov	 eax, 1167		; 0000048fH
  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ENDP	; XInputSetStateStub
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_dwUserIndex$ = 8					; size = 4
_pState$ = 12						; size = 4
?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z PROC	; XInputGetStateStub

; 71   : XINPUT_GET_STATE(XInputGetStateStub) { return(ERROR_DEVICE_NOT_CONNECTED); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 8f 04 00 00	 mov	 eax, 1167		; 0000048fH
  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z ENDP	; XInputGetStateStub
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\barebones.cpp
_TEXT	SEGMENT
_row$ = -20						; size = 4
_pixel$1 = -16						; size = 4
_y$2 = -12						; size = 4
_x$3 = -8						; size = 4
_red$4 = -3						; size = 1
_green$5 = -2						; size = 1
_blue$6 = -1						; size = 1
_buffer$ = 8						; size = 4
_blueOffset$ = 12					; size = 4
_greenOffset$ = 16					; size = 4
_redOffset$ = 20					; size = 4
?RenderColor@@YAXPAUgame_offscreen_buffer@@HHH@Z PROC	; RenderColor

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 24   : 
; 25   : 	uint8* row = (uint8*)buffer->memory;

  00006	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d ec	 mov	 DWORD PTR _row$[ebp], ecx

; 26   : 	for (int y = 0; y < buffer->height; ++y)

  0000e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  00015	eb 09		 jmp	 SHORT $LN4@RenderColo
$LN2@RenderColo:
  00017	8b 55 f4	 mov	 edx, DWORD PTR _y$2[ebp]
  0001a	83 c2 01	 add	 edx, 1
  0001d	89 55 f4	 mov	 DWORD PTR _y$2[ebp], edx
$LN4@RenderColo:
  00020	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00023	8b 4d f4	 mov	 ecx, DWORD PTR _y$2[ebp]
  00026	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00029	7d 72		 jge	 SHORT $LN1@RenderColo

; 27   : 	{
; 28   : 		uint32* pixel = (uint32*)row;

  0002b	8b 55 ec	 mov	 edx, DWORD PTR _row$[ebp]
  0002e	89 55 f0	 mov	 DWORD PTR _pixel$1[ebp], edx

; 29   : 		for (int x = 0; x < buffer->width; ++x)

  00031	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$3[ebp], 0
  00038	eb 09		 jmp	 SHORT $LN7@RenderColo
$LN5@RenderColo:
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _x$3[ebp]
  0003d	83 c0 01	 add	 eax, 1
  00040	89 45 f8	 mov	 DWORD PTR _x$3[ebp], eax
$LN7@RenderColo:
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00046	8b 55 f8	 mov	 edx, DWORD PTR _x$3[ebp]
  00049	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0004c	7d 3e		 jge	 SHORT $LN6@RenderColo

; 30   : 		{
; 31   : 			/*
; 32   : 			* Memory:	BB GG RR xx
; 33   : 			* Register:	xx RR GG BB
; 34   : 			*/
; 35   : 			uint8 blue = (x + blueOffset);

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _x$3[ebp]
  00051	03 45 0c	 add	 eax, DWORD PTR _blueOffset$[ebp]
  00054	88 45 ff	 mov	 BYTE PTR _blue$6[ebp], al

; 36   : 			uint8 green = (y + greenOffset);

  00057	8b 4d f4	 mov	 ecx, DWORD PTR _y$2[ebp]
  0005a	03 4d 10	 add	 ecx, DWORD PTR _greenOffset$[ebp]
  0005d	88 4d fe	 mov	 BYTE PTR _green$5[ebp], cl

; 37   : 			uint8 red = (0 + redOffset);

  00060	8a 55 14	 mov	 dl, BYTE PTR _redOffset$[ebp]
  00063	88 55 fd	 mov	 BYTE PTR _red$4[ebp], dl

; 38   : 
; 39   : 			*pixel++ = (blue | (green << 8) | (red << 16));

  00066	0f b6 45 ff	 movzx	 eax, BYTE PTR _blue$6[ebp]
  0006a	0f b6 4d fe	 movzx	 ecx, BYTE PTR _green$5[ebp]
  0006e	c1 e1 08	 shl	 ecx, 8
  00071	0b c1		 or	 eax, ecx
  00073	0f b6 55 fd	 movzx	 edx, BYTE PTR _red$4[ebp]
  00077	c1 e2 10	 shl	 edx, 16			; 00000010H
  0007a	0b c2		 or	 eax, edx
  0007c	8b 4d f0	 mov	 ecx, DWORD PTR _pixel$1[ebp]
  0007f	89 01		 mov	 DWORD PTR [ecx], eax
  00081	8b 55 f0	 mov	 edx, DWORD PTR _pixel$1[ebp]
  00084	83 c2 04	 add	 edx, 4
  00087	89 55 f0	 mov	 DWORD PTR _pixel$1[ebp], edx

; 40   : 		}

  0008a	eb ae		 jmp	 SHORT $LN5@RenderColo
$LN6@RenderColo:

; 41   : 
; 42   : 		row += buffer->pitch;

  0008c	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0008f	8b 4d ec	 mov	 ecx, DWORD PTR _row$[ebp]
  00092	03 48 0c	 add	 ecx, DWORD PTR [eax+12]
  00095	89 4d ec	 mov	 DWORD PTR _row$[ebp], ecx

; 43   : 	}

  00098	e9 7a ff ff ff	 jmp	 $LN2@RenderColo
$LN1@RenderColo:

; 44   : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
?RenderColor@@YAXPAUgame_offscreen_buffer@@HHH@Z ENDP	; RenderColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\barebones.cpp
_TEXT	SEGMENT
_wavePeriod$ = -24					; size = 4
_sineValue$1 = -20					; size = 4
_SampleIndex$2 = -16					; size = 4
_sampleOut$ = -12					; size = 4
_toneVolume$ = -8					; size = 2
_sampleValue$3 = -4					; size = 2
_soundBuffer$ = 8					; size = 4
_toneHz$ = 12						; size = 4
?GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z PROC ; GameOutputSound

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 6    : 	local_persist real32 tSine;
; 7    : 	int16 toneVolume = 600;

  00006	b8 58 02 00 00	 mov	 eax, 600		; 00000258H
  0000b	66 89 45 f8	 mov	 WORD PTR _toneVolume$[ebp], ax

; 8    : 	int wavePeriod = soundBuffer->samplesPerSec / toneHz;

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _soundBuffer$[ebp]
  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	99		 cdq
  00015	f7 7d 0c	 idiv	 DWORD PTR _toneHz$[ebp]
  00018	89 45 e8	 mov	 DWORD PTR _wavePeriod$[ebp], eax

; 9    : 	int16* sampleOut = soundBuffer->samples;

  0001b	8b 55 08	 mov	 edx, DWORD PTR _soundBuffer$[ebp]
  0001e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00021	89 45 f4	 mov	 DWORD PTR _sampleOut$[ebp], eax

; 10   : 
; 11   : 	for (int SampleIndex = 0; SampleIndex < soundBuffer->sampleCount; ++SampleIndex)

  00024	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _SampleIndex$2[ebp], 0
  0002b	eb 09		 jmp	 SHORT $LN4@GameOutput
$LN2@GameOutput:
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _SampleIndex$2[ebp]
  00030	83 c1 01	 add	 ecx, 1
  00033	89 4d f0	 mov	 DWORD PTR _SampleIndex$2[ebp], ecx
$LN4@GameOutput:
  00036	8b 55 08	 mov	 edx, DWORD PTR _soundBuffer$[ebp]
  00039	8b 45 f0	 mov	 eax, DWORD PTR _SampleIndex$2[ebp]
  0003c	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0003f	7d 7a		 jge	 SHORT $LN3@GameOutput

; 12   : 	{
; 13   : 		real32 sineValue = sinf(tSine);

  00041	51		 push	 ecx
  00042	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?tSine@?1??GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z@4MA
  0004a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004f	e8 00 00 00 00	 call	 _sinf
  00054	83 c4 04	 add	 esp, 4
  00057	d9 5d ec	 fstp	 DWORD PTR _sineValue$1[ebp]

; 14   : 		int16 sampleValue = (int16)(sineValue * toneVolume);

  0005a	0f bf 4d f8	 movsx	 ecx, WORD PTR _toneVolume$[ebp]
  0005e	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00062	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _sineValue$1[ebp]
  00067	f3 0f 2c d0	 cvttss2si edx, xmm0
  0006b	66 89 55 fc	 mov	 WORD PTR _sampleValue$3[ebp], dx

; 15   : 		*sampleOut++ = sampleValue;

  0006f	8b 45 f4	 mov	 eax, DWORD PTR _sampleOut$[ebp]
  00072	66 8b 4d fc	 mov	 cx, WORD PTR _sampleValue$3[ebp]
  00076	66 89 08	 mov	 WORD PTR [eax], cx
  00079	8b 55 f4	 mov	 edx, DWORD PTR _sampleOut$[ebp]
  0007c	83 c2 02	 add	 edx, 2
  0007f	89 55 f4	 mov	 DWORD PTR _sampleOut$[ebp], edx

; 16   : 		*sampleOut++ = sampleValue;

  00082	8b 45 f4	 mov	 eax, DWORD PTR _sampleOut$[ebp]
  00085	66 8b 4d fc	 mov	 cx, WORD PTR _sampleValue$3[ebp]
  00089	66 89 08	 mov	 WORD PTR [eax], cx
  0008c	8b 55 f4	 mov	 edx, DWORD PTR _sampleOut$[ebp]
  0008f	83 c2 02	 add	 edx, 2
  00092	89 55 f4	 mov	 DWORD PTR _sampleOut$[ebp], edx

; 17   : 
; 18   : 		tSine += (2.0f * pi32 * 1.0f) / (real32)wavePeriod;

  00095	f3 0f 2a 45 e8	 cvtsi2ss xmm0, DWORD PTR _wavePeriod$[ebp]
  0009a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40c90fdb
  000a2	f3 0f 5e c8	 divss	 xmm1, xmm0
  000a6	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR ?tSine@?1??GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z@4MA
  000ae	f3 0f 11 0d 00
	00 00 00	 movss	 DWORD PTR ?tSine@?1??GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z@4MA, xmm1

; 19   : 	}

  000b6	e9 72 ff ff ff	 jmp	 $LN2@GameOutput
$LN3@GameOutput:

; 20   : }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
?GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z ENDP ; GameOutputSound
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv71 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 757  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 758  :             return (float)sin(_X);

  00004	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00009	83 ec 08	 sub	 esp, 8
  0000c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00011	e8 00 00 00 00	 call	 _sin
  00016	83 c4 08	 add	 esp, 8
  00019	d9 5d fc	 fstp	 DWORD PTR tv71[ebp]
  0001c	d9 45 fc	 fld	 DWORD PTR tv71[ebp]

; 759  :         }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\barebones.cpp
_TEXT	SEGMENT
_blueOffset$ = -12					; size = 4
_greenOffset$ = -8					; size = 4
_redOffset$ = -4					; size = 4
_buffer$ = 8						; size = 4
_soundBuffer$ = 12					; size = 4
_toneHz$ = 16						; size = 4
?GameUpdateAndRender@@YAXPAUgame_offscreen_buffer@@PAUgame_sound_output_buffer@@H@Z PROC ; GameUpdateAndRender

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 51   : 	int blueOffset = 0;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _blueOffset$[ebp], 0

; 52   : 	int greenOffset = 0;

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _greenOffset$[ebp], 0

; 53   : 	int redOffset = 0;

  00014	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _redOffset$[ebp], 0

; 54   : 
; 55   : 	GameOutputSound(soundBuffer, toneHz);

  0001b	8b 45 10	 mov	 eax, DWORD PTR _toneHz$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _soundBuffer$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ?GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z ; GameOutputSound
  00028	83 c4 08	 add	 esp, 8

; 56   : 	RenderColor(buffer, blueOffset, greenOffset, redOffset);

  0002b	8b 55 fc	 mov	 edx, DWORD PTR _redOffset$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _greenOffset$[ebp]
  00032	50		 push	 eax
  00033	8b 4d f4	 mov	 ecx, DWORD PTR _blueOffset$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 ?RenderColor@@YAXPAUgame_offscreen_buffer@@HHH@Z ; RenderColor
  00040	83 c4 10	 add	 esp, 16			; 00000010H

; 57   : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?GameUpdateAndRender@@YAXPAUgame_offscreen_buffer@@PAUgame_sound_output_buffer@@H@Z ENDP ; GameUpdateAndRender
_TEXT	ENDS
END
