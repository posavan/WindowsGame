; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33134.0 

	TITLE	W:\WindowsGame\build\win32_barebones.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z	; XInputGetStateStub
PUBLIC	?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ; XInputSetStateStub
CONST	SEGMENT
$SG95349 DB	'xinput1_4.dll', 00H
	ORG $+2
$SG95352 DB	'XInputGetState', 00H
	ORG $+1
$SG95354 DB	'XInputSetState', 00H
	ORG $+1
$SG95375 DB	'dsound.dll', 00H
	ORG $+1
$SG95378 DB	'DirectSoundCreate', 00H
	ORG $+2
$SG95387 DB	'Primary buffer format was set.', 0aH, 00H
$SG95390 DB	'Primary buffer format was set.', 0aH, 00H
$SG95482 DB	'WM_CLOSE', 0aH, 00H
	ORG $+2
$SG95484 DB	'WM_ACTIVATEAPP', 0aH, 00H
$SG95486 DB	'WM_DESTROY', 0aH, 00H
$SG95494 DB	'W: ', 00H
$SG95497 DB	'isDown ', 00H
$SG95499 DB	'wasDown ', 00H
	ORG $+3
$SG95500 DB	0aH, 00H
	ORG $+2
$SG95579 DB	'BareBonesWindowClass', 00H
	ORG $+3
$SG95582 DB	'Bare Bones', 00H
CONST	ENDS
PUBLIC	_WinMain@16
PUBLIC	_sinf
PUBLIC	_main
PUBLIC	__real@40c90fdb
PUBLIC	__real@43800000
PUBLIC	__real@46ea6000
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__VirtualAlloc@16:PROC
EXTRN	__imp__VirtualFree@12:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__StretchDIBits@52:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	_sin:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?g_running@@3HA DD 01H DUP (?)				; g_running
?g_back_buffer@@3Uoffscreen_buffer@@A DB 03cH DUP (?)	; g_back_buffer
?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A DD 01H DUP (?) ; g_secondary_buffer
_BSS	ENDS
;	COMDAT __real@46ea6000
CONST	SEGMENT
__real@46ea6000 DD 046ea6000r			; 30000
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
_DATA	SEGMENT
?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA DD FLAT:?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z ; xInputGetState_
?xInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA DD FLAT:?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ; xInputSetState_
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_main
	DD	010H
	DD	04a5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z
	DD	0dH
	DD	01e3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Win32GetWindowDimensions@@YA?AUwindow_dimensions@@PAUHWND__@@@Z
	DD	0dH
	DD	036H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Win32InitDSound@@YAXPAUHWND__@@HH@Z
	DD	0dH
	DD	0180H
voltbl	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_Message$1 = -260					; size = 28
_dPadRight$2 = -232					; size = 4
_buttonStart$3 = -228					; size = 4
_dPadUp$4 = -224					; size = 4
_dPadDown$5 = -220					; size = 4
_dPadLeft$6 = -216					; size = 4
_writeCursor$7 = -212					; size = 4
_buttonY$8 = -208					; size = 4
_buttonX$9 = -204					; size = 4
_buttonB$10 = -200					; size = 4
_buttonA$11 = -196					; size = 4
_shoulderRight$12 = -192				; size = 4
_shoulderLeft$13 = -188					; size = 4
_thumbRight$14 = -184					; size = 4
_thumbLeft$15 = -180					; size = 4
_buttonBack$16 = -176					; size = 4
_WindowClass$ = -172					; size = 40
$T17 = -132						; size = 8
_dimensions$18 = -124					; size = 8
_DeviceContext$19 = -116				; size = 4
_targetCursor$20 = -112					; size = 4
_inputState$21 = -108					; size = 4
_stickRX$22 = -104					; size = 2
_xOffset$23 = -100					; size = 4
_yOffset$24 = -96					; size = 4
_stickRY$25 = -92					; size = 2
_stickLY$26 = -88					; size = 2
_stickLX$27 = -84					; size = 2
_Window$28 = -80					; size = 4
_playCursor$29 = -76					; size = 4
_ctrlIndex$30 = -72					; size = 4
_byteToLock$31 = -68					; size = 4
_bytesToWrite$32 = -64					; size = 4
_pad$33 = -60						; size = 4
_state$34 = -56						; size = 16
_soundOutput$35 = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
_Instance$ = 8						; size = 4
_main	PROC

; 419  : int main(HINSTANCE Instance) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 420  : 	Win32LoadXInput();

  00013	e8 00 00 00 00	 call	 ?Win32LoadXInput@@YAXXZ	; Win32LoadXInput

; 421  : 
; 422  : 	WNDCLASSA WindowClass = {};

  00018	33 c0		 xor	 eax, eax
  0001a	89 85 54 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp], eax
  00020	89 85 58 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+4], eax
  00026	89 85 5c ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+8], eax
  0002c	89 85 60 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+12], eax
  00032	89 85 64 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+16], eax
  00038	89 85 68 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+20], eax
  0003e	89 85 6c ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+24], eax
  00044	89 85 70 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+28], eax
  0004a	89 85 74 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+32], eax
  00050	89 85 78 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+36], eax

; 423  : 
; 424  : 	Win32ResizeDIBSection(&g_back_buffer, 1280, 720);

  00056	68 d0 02 00 00	 push	 720			; 000002d0H
  0005b	68 00 05 00 00	 push	 1280			; 00000500H
  00060	68 00 00 00 00	 push	 OFFSET ?g_back_buffer@@3Uoffscreen_buffer@@A
  00065	e8 00 00 00 00	 call	 ?Win32ResizeDIBSection@@YAXPAUoffscreen_buffer@@HH@Z ; Win32ResizeDIBSection
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 425  : 
; 426  : 	WindowClass.style = CS_HREDRAW | CS_VREDRAW;

  0006d	c7 85 54 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp], 3

; 427  : 	WindowClass.lpfnWndProc = Win32MainWindowCallback;

  00077	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp+4], OFFSET ?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z ; Win32MainWindowCallback

; 428  : 	WindowClass.hInstance = Instance;

  00081	8b 4d 08	 mov	 ecx, DWORD PTR _Instance$[ebp]
  00084	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+16], ecx

; 429  : 	WindowClass.lpszClassName = "BareBonesWindowClass";

  0008a	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp+36], OFFSET $SG95579

; 430  : 
; 431  : 	if (RegisterClassA(&WindowClass))

  00094	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _WindowClass$[ebp]
  0009a	52		 push	 edx
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassA@4
  000a1	0f b7 c0	 movzx	 eax, ax
  000a4	85 c0		 test	 eax, eax
  000a6	0f 84 f7 03 00
	00		 je	 $LN9@main

; 432  : 	{
; 433  : 		HWND Window = CreateWindowExA(

  000ac	6a 00		 push	 0
  000ae	8b 4d 08	 mov	 ecx, DWORD PTR _Instance$[ebp]
  000b1	51		 push	 ecx
  000b2	6a 00		 push	 0
  000b4	6a 00		 push	 0
  000b6	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000bb	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000c0	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000c5	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000ca	68 00 00 cf 10	 push	 282001408		; 10cf0000H
  000cf	68 00 00 00 00	 push	 OFFSET $SG95582
  000d4	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _WindowClass$[ebp+36]
  000da	52		 push	 edx
  000db	6a 00		 push	 0
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  000e3	89 45 b0	 mov	 DWORD PTR _Window$28[ebp], eax

; 434  : 			0,
; 435  : 			WindowClass.lpszClassName,
; 436  : 			"Bare Bones",
; 437  : 			WS_OVERLAPPEDWINDOW | WS_VISIBLE,
; 438  : 			CW_USEDEFAULT,
; 439  : 			CW_USEDEFAULT,
; 440  : 			CW_USEDEFAULT,
; 441  : 			CW_USEDEFAULT,
; 442  : 			0,
; 443  : 			0,
; 444  : 			Instance,
; 445  : 			0);
; 446  : 		if (Window)

  000e6	83 7d b0 00	 cmp	 DWORD PTR _Window$28[ebp], 0
  000ea	0f 84 b3 03 00
	00		 je	 $LN11@main

; 447  : 		{
; 448  : 			HDC DeviceContext = GetDC(Window);

  000f0	8b 45 b0	 mov	 eax, DWORD PTR _Window$28[ebp]
  000f3	50		 push	 eax
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  000fa	89 45 8c	 mov	 DWORD PTR _DeviceContext$19[ebp], eax

; 449  : 
; 450  : 			// Graphics Test
; 451  : 			int xOffset = 0;

  000fd	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _xOffset$23[ebp], 0

; 452  : 			int yOffset = 0;

  00104	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _yOffset$24[ebp], 0

; 453  : 
; 454  : 			// Sound Test
; 455  : 			sound_output soundOutput = {};

  0010b	33 c9		 xor	 ecx, ecx
  0010d	89 4d d8	 mov	 DWORD PTR _soundOutput$35[ebp], ecx
  00110	89 4d dc	 mov	 DWORD PTR _soundOutput$35[ebp+4], ecx
  00113	89 4d e0	 mov	 DWORD PTR _soundOutput$35[ebp+8], ecx
  00116	89 4d e4	 mov	 DWORD PTR _soundOutput$35[ebp+12], ecx
  00119	89 4d e8	 mov	 DWORD PTR _soundOutput$35[ebp+16], ecx
  0011c	89 4d ec	 mov	 DWORD PTR _soundOutput$35[ebp+20], ecx
  0011f	89 4d f0	 mov	 DWORD PTR _soundOutput$35[ebp+24], ecx
  00122	89 4d f4	 mov	 DWORD PTR _soundOutput$35[ebp+28], ecx
  00125	89 4d f8	 mov	 DWORD PTR _soundOutput$35[ebp+32], ecx

; 456  : 
; 457  : 			soundOutput.samplesPerSec = 48000;

  00128	c7 45 d8 80 bb
	00 00		 mov	 DWORD PTR _soundOutput$35[ebp], 48000 ; 0000bb80H

; 458  : 			soundOutput.toneHz = 256;

  0012f	c7 45 dc 00 01
	00 00		 mov	 DWORD PTR _soundOutput$35[ebp+4], 256 ; 00000100H

; 459  : 			soundOutput.toneVolume = 3000;

  00136	ba b8 0b 00 00	 mov	 edx, 3000		; 00000bb8H
  0013b	66 89 55 e0	 mov	 WORD PTR _soundOutput$35[ebp+8], dx

; 460  : 			soundOutput.runningSampleIndex = 0;

  0013f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _soundOutput$35[ebp+12], 0

; 461  : 			soundOutput.wavePeriod = soundOutput.samplesPerSec / soundOutput.toneHz;

  00146	8b 45 d8	 mov	 eax, DWORD PTR _soundOutput$35[ebp]
  00149	99		 cdq
  0014a	f7 7d dc	 idiv	 DWORD PTR _soundOutput$35[ebp+4]
  0014d	89 45 e8	 mov	 DWORD PTR _soundOutput$35[ebp+16], eax

; 462  : 			soundOutput.bytesPerSample = sizeof(int16) * 2;

  00150	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _soundOutput$35[ebp+20], 4

; 463  : 			soundOutput.bufferSize = soundOutput.samplesPerSec * soundOutput.bytesPerSample;

  00157	8b 45 d8	 mov	 eax, DWORD PTR _soundOutput$35[ebp]
  0015a	0f af 45 ec	 imul	 eax, DWORD PTR _soundOutput$35[ebp+20]
  0015e	89 45 f0	 mov	 DWORD PTR _soundOutput$35[ebp+24], eax

; 464  : 			soundOutput.latencySample = soundOutput.samplesPerSec / 15;

  00161	8b 45 d8	 mov	 eax, DWORD PTR _soundOutput$35[ebp]
  00164	99		 cdq
  00165	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0016a	f7 f9		 idiv	 ecx
  0016c	89 45 f8	 mov	 DWORD PTR _soundOutput$35[ebp+32], eax

; 465  : 
; 466  : 			Win32InitDSound(Window, soundOutput.samplesPerSec, soundOutput.bufferSize);

  0016f	8b 55 f0	 mov	 edx, DWORD PTR _soundOutput$35[ebp+24]
  00172	52		 push	 edx
  00173	8b 45 d8	 mov	 eax, DWORD PTR _soundOutput$35[ebp]
  00176	50		 push	 eax
  00177	8b 4d b0	 mov	 ecx, DWORD PTR _Window$28[ebp]
  0017a	51		 push	 ecx
  0017b	e8 00 00 00 00	 call	 ?Win32InitDSound@@YAXPAUHWND__@@HH@Z ; Win32InitDSound
  00180	83 c4 0c	 add	 esp, 12			; 0000000cH

; 467  : 			Win32FillSoundBuffer(&soundOutput, 0, soundOutput.latencySample * soundOutput.bytesPerSample);

  00183	8b 55 f8	 mov	 edx, DWORD PTR _soundOutput$35[ebp+32]
  00186	0f af 55 ec	 imul	 edx, DWORD PTR _soundOutput$35[ebp+20]
  0018a	52		 push	 edx
  0018b	6a 00		 push	 0
  0018d	8d 45 d8	 lea	 eax, DWORD PTR _soundOutput$35[ebp]
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 ?Win32FillSoundBuffer@@YAXPAUsound_output@@KK@Z ; Win32FillSoundBuffer
  00196	83 c4 0c	 add	 esp, 12			; 0000000cH

; 468  : 			g_secondary_buffer->Play(0, 0, DSBPLAY_LOOPING);

  00199	6a 01		 push	 1
  0019b	6a 00		 push	 0
  0019d	6a 00		 push	 0
  0019f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  001a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  001ac	50		 push	 eax
  001ad	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  001b0	ff d1		 call	 ecx

; 469  : 
; 470  : 			g_running = true;

  001b2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_running@@3HA, 1
$LN2@main:

; 471  : 			while (g_running)

  001bc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_running@@3HA, 0
  001c3	0f 84 da 02 00
	00		 je	 $LN3@main
$LN4@main:

; 472  : 			{
; 473  : 				MSG Message;
; 474  : 				while (PeekMessage(&Message, 0, 0, 0, PM_REMOVE))

  001c9	6a 01		 push	 1
  001cb	6a 00		 push	 0
  001cd	6a 00		 push	 0
  001cf	6a 00		 push	 0
  001d1	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _Message$1[ebp]
  001d7	52		 push	 edx
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  001de	85 c0		 test	 eax, eax
  001e0	74 2f		 je	 SHORT $LN5@main

; 475  : 				{
; 476  : 					if (Message.message == WM_QUIT)

  001e2	83 bd 00 ff ff
	ff 12		 cmp	 DWORD PTR _Message$1[ebp+4], 18 ; 00000012H
  001e9	75 0a		 jne	 SHORT $LN13@main

; 477  : 					{
; 478  : 						g_running = false;

  001eb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_running@@3HA, 0
$LN13@main:

; 479  : 					}
; 480  : 
; 481  : 					TranslateMessage(&Message);

  001f5	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _Message$1[ebp]
  001fb	50		 push	 eax
  001fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TranslateMessage@4

; 482  : 					DispatchMessageA(&Message);

  00202	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _Message$1[ebp]
  00208	51		 push	 ecx
  00209	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DispatchMessageA@4

; 483  : 				}

  0020f	eb b8		 jmp	 SHORT $LN4@main
$LN5@main:

; 484  : 
; 485  : 				// Controller
; 486  : 				for (DWORD ctrlIndex = 0; ctrlIndex < XUSER_MAX_COUNT; ++ctrlIndex)

  00211	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _ctrlIndex$30[ebp], 0
  00218	eb 09		 jmp	 SHORT $LN8@main
$LN6@main:
  0021a	8b 55 b8	 mov	 edx, DWORD PTR _ctrlIndex$30[ebp]
  0021d	83 c2 01	 add	 edx, 1
  00220	89 55 b8	 mov	 DWORD PTR _ctrlIndex$30[ebp], edx
$LN8@main:
  00223	83 7d b8 04	 cmp	 DWORD PTR _ctrlIndex$30[ebp], 4
  00227	0f 83 91 01 00
	00		 jae	 $LN7@main

; 487  : 				{
; 488  : 					XINPUT_STATE state;
; 489  : 					DWORD inputState = XInputGetState(ctrlIndex, &state);

  0022d	8d 45 c8	 lea	 eax, DWORD PTR _state$34[ebp]
  00230	50		 push	 eax
  00231	8b 4d b8	 mov	 ecx, DWORD PTR _ctrlIndex$30[ebp]
  00234	51		 push	 ecx
  00235	ff 15 00 00 00
	00		 call	 DWORD PTR ?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA
  0023b	89 45 94	 mov	 DWORD PTR _inputState$21[ebp], eax

; 490  : 
; 491  : 					// Controller Mapping
; 492  : 					if (inputState == ERROR_SUCCESS)

  0023e	83 7d 94 00	 cmp	 DWORD PTR _inputState$21[ebp], 0
  00242	0f 85 71 01 00
	00		 jne	 $LN14@main

; 493  : 					{
; 494  : 						// This controller is plugged in
; 495  : 						XINPUT_GAMEPAD* pad = &state.Gamepad;

  00248	8d 55 cc	 lea	 edx, DWORD PTR _state$34[ebp+4]
  0024b	89 55 c4	 mov	 DWORD PTR _pad$33[ebp], edx

; 496  : 
; 497  : 						bool32 dPadUp = (pad->wButtons & XINPUT_GAMEPAD_DPAD_UP);

  0024e	8b 45 c4	 mov	 eax, DWORD PTR _pad$33[ebp]
  00251	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00254	83 e1 01	 and	 ecx, 1
  00257	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _dPadUp$4[ebp], ecx

; 498  : 						bool32 dPadDown = (pad->wButtons & XINPUT_GAMEPAD_DPAD_DOWN);

  0025d	8b 55 c4	 mov	 edx, DWORD PTR _pad$33[ebp]
  00260	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00263	83 e0 02	 and	 eax, 2
  00266	89 85 24 ff ff
	ff		 mov	 DWORD PTR _dPadDown$5[ebp], eax

; 499  : 						bool32 dPadLeft = (pad->wButtons & XINPUT_GAMEPAD_DPAD_LEFT);

  0026c	8b 4d c4	 mov	 ecx, DWORD PTR _pad$33[ebp]
  0026f	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00272	83 e2 04	 and	 edx, 4
  00275	89 95 28 ff ff
	ff		 mov	 DWORD PTR _dPadLeft$6[ebp], edx

; 500  : 						bool32 dPadRight = (pad->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT);

  0027b	8b 45 c4	 mov	 eax, DWORD PTR _pad$33[ebp]
  0027e	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00281	83 e1 08	 and	 ecx, 8
  00284	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _dPadRight$2[ebp], ecx

; 501  : 						bool32 buttonStart = (pad->wButtons & XINPUT_GAMEPAD_START);

  0028a	8b 55 c4	 mov	 edx, DWORD PTR _pad$33[ebp]
  0028d	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00290	83 e0 10	 and	 eax, 16			; 00000010H
  00293	89 85 1c ff ff
	ff		 mov	 DWORD PTR _buttonStart$3[ebp], eax

; 502  : 						bool32 buttonBack = (pad->wButtons & XINPUT_GAMEPAD_BACK);

  00299	8b 4d c4	 mov	 ecx, DWORD PTR _pad$33[ebp]
  0029c	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0029f	83 e2 20	 and	 edx, 32			; 00000020H
  002a2	89 95 50 ff ff
	ff		 mov	 DWORD PTR _buttonBack$16[ebp], edx

; 503  : 						bool32 thumbLeft = (pad->wButtons & XINPUT_GAMEPAD_LEFT_THUMB);

  002a8	8b 45 c4	 mov	 eax, DWORD PTR _pad$33[ebp]
  002ab	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  002ae	83 e1 40	 and	 ecx, 64			; 00000040H
  002b1	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _thumbLeft$15[ebp], ecx

; 504  : 						bool32 thumbRight = (pad->wButtons & XINPUT_GAMEPAD_RIGHT_THUMB);

  002b7	8b 55 c4	 mov	 edx, DWORD PTR _pad$33[ebp]
  002ba	0f b7 02	 movzx	 eax, WORD PTR [edx]
  002bd	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002c2	89 85 48 ff ff
	ff		 mov	 DWORD PTR _thumbRight$14[ebp], eax

; 505  : 						bool32 shoulderLeft = (pad->wButtons & XINPUT_GAMEPAD_LEFT_SHOULDER);

  002c8	8b 4d c4	 mov	 ecx, DWORD PTR _pad$33[ebp]
  002cb	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  002ce	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  002d4	89 95 44 ff ff
	ff		 mov	 DWORD PTR _shoulderLeft$13[ebp], edx

; 506  : 						bool32 shoulderRight = (pad->wButtons & XINPUT_GAMEPAD_RIGHT_SHOULDER);

  002da	8b 45 c4	 mov	 eax, DWORD PTR _pad$33[ebp]
  002dd	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  002e0	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  002e6	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _shoulderRight$12[ebp], ecx

; 507  : 						bool32 buttonA = (pad->wButtons & XINPUT_GAMEPAD_A);

  002ec	8b 55 c4	 mov	 edx, DWORD PTR _pad$33[ebp]
  002ef	0f b7 02	 movzx	 eax, WORD PTR [edx]
  002f2	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  002f7	89 85 3c ff ff
	ff		 mov	 DWORD PTR _buttonA$11[ebp], eax

; 508  : 						bool32 buttonB = (pad->wButtons & XINPUT_GAMEPAD_B);

  002fd	8b 4d c4	 mov	 ecx, DWORD PTR _pad$33[ebp]
  00300	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00303	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  00309	89 95 38 ff ff
	ff		 mov	 DWORD PTR _buttonB$10[ebp], edx

; 509  : 						bool32 buttonX = (pad->wButtons & XINPUT_GAMEPAD_X);

  0030f	8b 45 c4	 mov	 eax, DWORD PTR _pad$33[ebp]
  00312	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00315	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  0031b	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _buttonX$9[ebp], ecx

; 510  : 						bool32 buttonY = (pad->wButtons & XINPUT_GAMEPAD_Y);

  00321	8b 55 c4	 mov	 edx, DWORD PTR _pad$33[ebp]
  00324	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00327	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  0032c	89 85 30 ff ff
	ff		 mov	 DWORD PTR _buttonY$8[ebp], eax

; 511  : 
; 512  : 						int16 stickLX = pad->sThumbLX;

  00332	8b 4d c4	 mov	 ecx, DWORD PTR _pad$33[ebp]
  00335	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00339	66 89 55 ac	 mov	 WORD PTR _stickLX$27[ebp], dx

; 513  : 						int16 stickLY = pad->sThumbLY;

  0033d	8b 45 c4	 mov	 eax, DWORD PTR _pad$33[ebp]
  00340	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  00344	66 89 4d a8	 mov	 WORD PTR _stickLY$26[ebp], cx

; 514  : 						int16 stickRX = pad->sThumbRX;

  00348	8b 55 c4	 mov	 edx, DWORD PTR _pad$33[ebp]
  0034b	66 8b 42 08	 mov	 ax, WORD PTR [edx+8]
  0034f	66 89 45 98	 mov	 WORD PTR _stickRX$22[ebp], ax

; 515  : 						int16 stickRY = pad->sThumbRY;

  00353	8b 4d c4	 mov	 ecx, DWORD PTR _pad$33[ebp]
  00356	66 8b 51 0a	 mov	 dx, WORD PTR [ecx+10]
  0035a	66 89 55 a4	 mov	 WORD PTR _stickRY$25[ebp], dx

; 516  : 
; 517  : 						// doesn't properly deal with deadzone
; 518  : 						xOffset += stickLX / 4096;

  0035e	0f bf 45 ac	 movsx	 eax, WORD PTR _stickLX$27[ebp]
  00362	99		 cdq
  00363	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  00369	03 c2		 add	 eax, edx
  0036b	c1 f8 0c	 sar	 eax, 12			; 0000000cH
  0036e	03 45 9c	 add	 eax, DWORD PTR _xOffset$23[ebp]
  00371	89 45 9c	 mov	 DWORD PTR _xOffset$23[ebp], eax

; 519  : 						yOffset += stickLY / 4096;

  00374	0f bf 45 a8	 movsx	 eax, WORD PTR _stickLY$26[ebp]
  00378	99		 cdq
  00379	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  0037f	03 c2		 add	 eax, edx
  00381	c1 f8 0c	 sar	 eax, 12			; 0000000cH
  00384	03 45 a0	 add	 eax, DWORD PTR _yOffset$24[ebp]
  00387	89 45 a0	 mov	 DWORD PTR _yOffset$24[ebp], eax

; 520  : 
; 521  : 						soundOutput.toneHz = 512 + (int)(256.0f * ((real32)stickRY / 30000.0f));

  0038a	0f bf 45 a4	 movsx	 eax, WORD PTR _stickRY$25[ebp]
  0038e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00392	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46ea6000
  0039a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@43800000
  003a2	f3 0f 2c c8	 cvttss2si ecx, xmm0
  003a6	81 c1 00 02 00
	00		 add	 ecx, 512		; 00000200H
  003ac	89 4d dc	 mov	 DWORD PTR _soundOutput$35[ebp+4], ecx

; 522  : 						soundOutput.wavePeriod = soundOutput.samplesPerSec / soundOutput.toneHz;

  003af	8b 45 d8	 mov	 eax, DWORD PTR _soundOutput$35[ebp]
  003b2	99		 cdq
  003b3	f7 7d dc	 idiv	 DWORD PTR _soundOutput$35[ebp+4]
  003b6	89 45 e8	 mov	 DWORD PTR _soundOutput$35[ebp+16], eax
$LN14@main:

; 523  : 					}
; 524  : 					else
; 525  : 					{
; 526  : 						// This controller is not available
; 527  : 					}
; 528  : 				}

  003b9	e9 5c fe ff ff	 jmp	 $LN6@main
$LN7@main:

; 529  : 
; 530  : 				Win32RenderColor(&g_back_buffer, xOffset, yOffset, 0);

  003be	6a 00		 push	 0
  003c0	8b 55 a0	 mov	 edx, DWORD PTR _yOffset$24[ebp]
  003c3	52		 push	 edx
  003c4	8b 45 9c	 mov	 eax, DWORD PTR _xOffset$23[ebp]
  003c7	50		 push	 eax
  003c8	68 00 00 00 00	 push	 OFFSET ?g_back_buffer@@3Uoffscreen_buffer@@A
  003cd	e8 00 00 00 00	 call	 ?Win32RenderColor@@YAXPAUoffscreen_buffer@@HHH@Z ; Win32RenderColor
  003d2	83 c4 10	 add	 esp, 16			; 00000010H

; 531  : 
; 532  : #pragma region DirectSoundTest
; 533  : 				DWORD playCursor;
; 534  : 				DWORD writeCursor;
; 535  : 				if (SUCCEEDED(g_secondary_buffer->GetCurrentPosition(&playCursor, &writeCursor)))

  003d5	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _writeCursor$7[ebp]
  003db	51		 push	 ecx
  003dc	8d 55 b4	 lea	 edx, DWORD PTR _playCursor$29[ebp]
  003df	52		 push	 edx
  003e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  003e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  003ed	52		 push	 edx
  003ee	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  003f1	ff d0		 call	 eax
  003f3	85 c0		 test	 eax, eax
  003f5	7c 6a		 jl	 SHORT $LN16@main

; 536  : 				{
; 537  : 					DWORD byteToLock = ((soundOutput.runningSampleIndex * soundOutput.bytesPerSample) %

  003f7	8b 45 e4	 mov	 eax, DWORD PTR _soundOutput$35[ebp+12]
  003fa	0f af 45 ec	 imul	 eax, DWORD PTR _soundOutput$35[ebp+20]
  003fe	33 d2		 xor	 edx, edx
  00400	f7 75 f0	 div	 DWORD PTR _soundOutput$35[ebp+24]
  00403	89 55 bc	 mov	 DWORD PTR _byteToLock$31[ebp], edx

; 538  : 						soundOutput.bufferSize);
; 539  : 					DWORD targetCursor = playCursor +

  00406	8b 45 f8	 mov	 eax, DWORD PTR _soundOutput$35[ebp+32]
  00409	0f af 45 ec	 imul	 eax, DWORD PTR _soundOutput$35[ebp+20]
  0040d	99		 cdq
  0040e	f7 7d f0	 idiv	 DWORD PTR _soundOutput$35[ebp+24]
  00411	03 55 b4	 add	 edx, DWORD PTR _playCursor$29[ebp]
  00414	89 55 90	 mov	 DWORD PTR _targetCursor$20[ebp], edx

; 540  : 						(soundOutput.latencySample * soundOutput.bytesPerSample) %
; 541  : 						soundOutput.bufferSize;
; 542  : 					DWORD bytesToWrite;
; 543  : 
; 544  : 					if (byteToLock == playCursor)

  00417	8b 4d bc	 mov	 ecx, DWORD PTR _byteToLock$31[ebp]
  0041a	3b 4d b4	 cmp	 ecx, DWORD PTR _playCursor$29[ebp]
  0041d	75 09		 jne	 SHORT $LN17@main

; 545  : 					{
; 546  : 						bytesToWrite = 0;

  0041f	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _bytesToWrite$32[ebp], 0

; 547  : 					}

  00426	eb 25		 jmp	 SHORT $LN20@main
$LN17@main:

; 548  : 					else if (byteToLock > playCursor)

  00428	8b 55 bc	 mov	 edx, DWORD PTR _byteToLock$31[ebp]
  0042b	3b 55 b4	 cmp	 edx, DWORD PTR _playCursor$29[ebp]
  0042e	76 14		 jbe	 SHORT $LN19@main

; 549  : 					{
; 550  : 						bytesToWrite = (soundOutput.bufferSize - byteToLock);

  00430	8b 45 f0	 mov	 eax, DWORD PTR _soundOutput$35[ebp+24]
  00433	2b 45 bc	 sub	 eax, DWORD PTR _byteToLock$31[ebp]
  00436	89 45 c0	 mov	 DWORD PTR _bytesToWrite$32[ebp], eax

; 551  : 						bytesToWrite += playCursor;

  00439	8b 4d c0	 mov	 ecx, DWORD PTR _bytesToWrite$32[ebp]
  0043c	03 4d b4	 add	 ecx, DWORD PTR _playCursor$29[ebp]
  0043f	89 4d c0	 mov	 DWORD PTR _bytesToWrite$32[ebp], ecx

; 552  : 					}

  00442	eb 09		 jmp	 SHORT $LN20@main
$LN19@main:

; 553  : 					else
; 554  : 					{
; 555  : 						bytesToWrite = targetCursor - byteToLock;

  00444	8b 55 90	 mov	 edx, DWORD PTR _targetCursor$20[ebp]
  00447	2b 55 bc	 sub	 edx, DWORD PTR _byteToLock$31[ebp]
  0044a	89 55 c0	 mov	 DWORD PTR _bytesToWrite$32[ebp], edx
$LN20@main:

; 556  : 					}
; 557  : 
; 558  : 					Win32FillSoundBuffer(&soundOutput, byteToLock, bytesToWrite);

  0044d	8b 45 c0	 mov	 eax, DWORD PTR _bytesToWrite$32[ebp]
  00450	50		 push	 eax
  00451	8b 4d bc	 mov	 ecx, DWORD PTR _byteToLock$31[ebp]
  00454	51		 push	 ecx
  00455	8d 55 d8	 lea	 edx, DWORD PTR _soundOutput$35[ebp]
  00458	52		 push	 edx
  00459	e8 00 00 00 00	 call	 ?Win32FillSoundBuffer@@YAXPAUsound_output@@KK@Z ; Win32FillSoundBuffer
  0045e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@main:

; 559  : 				}
; 560  : #pragma endregion
; 561  : 
; 562  : 				window_dimensions dimensions = Win32GetWindowDimensions(Window);

  00461	8b 45 b0	 mov	 eax, DWORD PTR _Window$28[ebp]
  00464	50		 push	 eax
  00465	e8 00 00 00 00	 call	 ?Win32GetWindowDimensions@@YA?AUwindow_dimensions@@PAUHWND__@@@Z ; Win32GetWindowDimensions
  0046a	83 c4 04	 add	 esp, 4
  0046d	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T17[ebp], eax
  00473	89 55 80	 mov	 DWORD PTR $T17[ebp+4], edx
  00476	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR $T17[ebp]
  0047c	8b 55 80	 mov	 edx, DWORD PTR $T17[ebp+4]
  0047f	89 4d 84	 mov	 DWORD PTR _dimensions$18[ebp], ecx
  00482	89 55 88	 mov	 DWORD PTR _dimensions$18[ebp+4], edx

; 563  : 				Win32DisplayBufferToWindow(

  00485	8b 45 88	 mov	 eax, DWORD PTR _dimensions$18[ebp+4]
  00488	50		 push	 eax
  00489	8b 4d 84	 mov	 ecx, DWORD PTR _dimensions$18[ebp]
  0048c	51		 push	 ecx
  0048d	8b 55 8c	 mov	 edx, DWORD PTR _DeviceContext$19[ebp]
  00490	52		 push	 edx
  00491	68 00 00 00 00	 push	 OFFSET ?g_back_buffer@@3Uoffscreen_buffer@@A
  00496	e8 00 00 00 00	 call	 ?Win32DisplayBufferToWindow@@YAXPAUoffscreen_buffer@@PAUHDC__@@HH@Z ; Win32DisplayBufferToWindow
  0049b	83 c4 10	 add	 esp, 16			; 00000010H

; 564  : 					&g_back_buffer,
; 565  : 					DeviceContext,
; 566  : 					dimensions.width, dimensions.height);
; 567  : 
; 568  : 			}

  0049e	e9 19 fd ff ff	 jmp	 $LN2@main
$LN3@main:
$LN11@main:
$LN9@main:

; 569  : 		}
; 570  : 		else
; 571  : 		{
; 572  : 			//log
; 573  : 		}
; 574  : 	}
; 575  : 	else
; 576  : 	{
; 577  : 		//log
; 578  : 	}
; 579  : 
; 580  : }

  004a3	33 c0		 xor	 eax, eax
  004a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a8	33 cd		 xor	 ecx, ebp
  004aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004af	8b e5		 mov	 esp, ebp
  004b1	5d		 pop	 ebp
  004b2	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_dimensions$1 = -120					; size = 8
$T2 = -112						; size = 8
_DeviceContext$3 = -104					; size = 4
_AltKeyDown$4 = -100					; size = 4
_result$ = -96						; size = 4
_wasDown$5 = -92					; size = 4
_isDown$6 = -88						; size = 4
tv73 = -84						; size = 4
tv70 = -80						; size = 4
tv64 = -76						; size = 4
_VKCode$7 = -72						; size = 4
_Paint$8 = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_Window$ = 8						; size = 4
_Message$ = 12						; size = 4
_WParam$ = 16						; size = 4
_LParam$ = 20						; size = 4
?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z PROC	; Win32MainWindowCallback

; 311  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 312  : 	LRESULT result = 0;

  00010	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 313  : 
; 314  : 	switch (Message)

  00017	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  0001a	89 45 b4	 mov	 DWORD PTR tv64[ebp], eax
  0001d	81 7d b4 00 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 256 ; 00000100H
  00024	77 31		 ja	 SHORT $LN46@Win32MainW
  00026	81 7d b4 00 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 256 ; 00000100H
  0002d	0f 84 88 00 00
	00		 je	 $LN10@Win32MainW
  00033	8b 4d b4	 mov	 ecx, DWORD PTR tv64[ebp]
  00036	83 e9 02	 sub	 ecx, 2
  00039	89 4d b4	 mov	 DWORD PTR tv64[ebp], ecx
  0003c	83 7d b4 1a	 cmp	 DWORD PTR tv64[ebp], 26	; 0000001aH
  00040	0f 87 81 01 00
	00		 ja	 $LN40@Win32MainW
  00046	8b 55 b4	 mov	 edx, DWORD PTR tv64[ebp]
  00049	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN47@Win32MainW[edx]
  00050	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN48@Win32MainW[eax*4]
$LN46@Win32MainW:
  00057	81 7d b4 01 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 257 ; 00000101H
  0005e	74 5b		 je	 SHORT $LN10@Win32MainW
  00060	81 7d b4 04 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 260 ; 00000104H
  00067	74 52		 je	 SHORT $LN10@Win32MainW
  00069	81 7d b4 05 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 261 ; 00000105H
  00070	74 49		 je	 SHORT $LN10@Win32MainW
  00072	e9 50 01 00 00	 jmp	 $LN40@Win32MainW
$LN4@Win32MainW:

; 315  : 	{
; 316  : 	case WM_CLOSE:
; 317  : 	{
; 318  : 		g_running = false;

  00077	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_running@@3HA, 0

; 319  : 		OutputDebugStringA("WM_CLOSE\n");

  00081	68 00 00 00 00	 push	 OFFSET $SG95482
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 320  : 	} break;

  0008c	e9 4f 01 00 00	 jmp	 $LN2@Win32MainW
$LN5@Win32MainW:

; 321  : 	case WM_ACTIVATEAPP:
; 322  : 	{
; 323  : 		OutputDebugStringA("WM_ACTIVATEAPP\n");

  00091	68 00 00 00 00	 push	 OFFSET $SG95484
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 324  : 	} break;

  0009c	e9 3f 01 00 00	 jmp	 $LN2@Win32MainW
$LN6@Win32MainW:

; 325  : 	case WM_DESTROY:
; 326  : 	{
; 327  : 		g_running = false;

  000a1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_running@@3HA, 0

; 328  : 		OutputDebugStringA("WM_DESTROY\n");

  000ab	68 00 00 00 00	 push	 OFFSET $SG95486
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 329  : 	} break;

  000b6	e9 25 01 00 00	 jmp	 $LN2@Win32MainW
$LN10@Win32MainW:

; 330  : 
; 331  : 	case WM_SYSKEYDOWN:
; 332  : 	case WM_SYSKEYUP:
; 333  : 	case WM_KEYDOWN:
; 334  : 	case WM_KEYUP:
; 335  : 	{
; 336  : 		uint32 VKCode = WParam;

  000bb	8b 4d 10	 mov	 ecx, DWORD PTR _WParam$[ebp]
  000be	89 4d b8	 mov	 DWORD PTR _VKCode$7[ebp], ecx

; 337  : 		bool32 wasDown = ((LParam & (1 << 30)) != 0);

  000c1	8b 55 14	 mov	 edx, DWORD PTR _LParam$[ebp]
  000c4	81 e2 00 00 00
	40		 and	 edx, 1073741824		; 40000000H
  000ca	74 09		 je	 SHORT $LN42@Win32MainW
  000cc	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  000d3	eb 07		 jmp	 SHORT $LN43@Win32MainW
$LN42@Win32MainW:
  000d5	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN43@Win32MainW:
  000dc	8b 45 b0	 mov	 eax, DWORD PTR tv70[ebp]
  000df	89 45 a4	 mov	 DWORD PTR _wasDown$5[ebp], eax

; 338  : 		bool32 isDown = ((LParam & (1 << 31)) == 0);

  000e2	8b 4d 14	 mov	 ecx, DWORD PTR _LParam$[ebp]
  000e5	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  000eb	75 09		 jne	 SHORT $LN44@Win32MainW
  000ed	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  000f4	eb 07		 jmp	 SHORT $LN45@Win32MainW
$LN44@Win32MainW:
  000f6	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN45@Win32MainW:
  000fd	8b 55 ac	 mov	 edx, DWORD PTR tv73[ebp]
  00100	89 55 a8	 mov	 DWORD PTR _isDown$6[ebp], edx

; 339  : 		if (wasDown != isDown)

  00103	8b 45 a4	 mov	 eax, DWORD PTR _wasDown$5[ebp]
  00106	3b 45 a8	 cmp	 eax, DWORD PTR _isDown$6[ebp]
  00109	74 40		 je	 SHORT $LN11@Win32MainW

; 340  : 		{
; 341  : 			if (VKCode == 'W')

  0010b	83 7d b8 57	 cmp	 DWORD PTR _VKCode$7[ebp], 87 ; 00000057H
  0010f	75 3a		 jne	 SHORT $LN11@Win32MainW

; 342  : 			{
; 343  : 				OutputDebugStringA("W: ");

  00111	68 00 00 00 00	 push	 OFFSET $SG95494
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 344  : 				if (isDown)

  0011c	83 7d a8 00	 cmp	 DWORD PTR _isDown$6[ebp], 0
  00120	74 0d		 je	 SHORT $LN14@Win32MainW

; 345  : 				{
; 346  : 					OutputDebugStringA("isDown ");

  00122	68 00 00 00 00	 push	 OFFSET $SG95497
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 347  : 				}

  0012d	eb 11		 jmp	 SHORT $LN15@Win32MainW
$LN14@Win32MainW:

; 348  : 				else if (wasDown)

  0012f	83 7d a4 00	 cmp	 DWORD PTR _wasDown$5[ebp], 0
  00133	74 0b		 je	 SHORT $LN15@Win32MainW

; 349  : 				{
; 350  : 					OutputDebugStringA("wasDown ");

  00135	68 00 00 00 00	 push	 OFFSET $SG95499
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
$LN15@Win32MainW:

; 351  : 				}
; 352  : 				OutputDebugStringA("\n");

  00140	68 00 00 00 00	 push	 OFFSET $SG95500
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
$LN11@Win32MainW:

; 353  : 			}
; 354  : 			else if (VKCode == 'A')
; 355  : 			{
; 356  : 			}
; 357  : 			else if (VKCode == 'S')
; 358  : 			{
; 359  : 			}
; 360  : 			else if (VKCode == 'D')
; 361  : 			{
; 362  : 			}
; 363  : 			else if (VKCode == 'Q')
; 364  : 			{
; 365  : 			}
; 366  : 			else if (VKCode == 'E')
; 367  : 			{
; 368  : 			}
; 369  : 			else if (VKCode == VK_UP)
; 370  : 			{
; 371  : 			}
; 372  : 			else if (VKCode == VK_LEFT)
; 373  : 			{
; 374  : 			}
; 375  : 			else if (VKCode == VK_DOWN)
; 376  : 			{
; 377  : 			}
; 378  : 			else if (VKCode == VK_RIGHT)
; 379  : 			{
; 380  : 			}
; 381  : 			else if (VKCode == VK_ESCAPE)
; 382  : 			{
; 383  : 			}
; 384  : 			else if (VKCode == VK_SPACE)
; 385  : 			{
; 386  : 			}
; 387  : 		}
; 388  : 
; 389  : 		bool32 AltKeyDown = (LParam & (1 << 29));

  0014b	8b 4d 14	 mov	 ecx, DWORD PTR _LParam$[ebp]
  0014e	81 e1 00 00 00
	20		 and	 ecx, 536870912		; 20000000H
  00154	89 4d 9c	 mov	 DWORD PTR _AltKeyDown$4[ebp], ecx

; 390  : 		if ((VKCode == VK_F4) && AltKeyDown)

  00157	83 7d b8 73	 cmp	 DWORD PTR _VKCode$7[ebp], 115 ; 00000073H
  0015b	75 10		 jne	 SHORT $LN38@Win32MainW
  0015d	83 7d 9c 00	 cmp	 DWORD PTR _AltKeyDown$4[ebp], 0
  00161	74 0a		 je	 SHORT $LN38@Win32MainW

; 391  : 		{
; 392  : 			g_running = false;

  00163	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_running@@3HA, 0
$LN38@Win32MainW:

; 393  : 		}
; 394  : 
; 395  : 	} break;

  0016d	eb 71		 jmp	 SHORT $LN2@Win32MainW
$LN39@Win32MainW:

; 396  : 
; 397  : 	case WM_PAINT:
; 398  : 	{
; 399  : 		PAINTSTRUCT Paint;
; 400  : 		HDC DeviceContext = BeginPaint(Window, &Paint);

  0016f	8d 55 bc	 lea	 edx, DWORD PTR _Paint$8[ebp]
  00172	52		 push	 edx
  00173	8b 45 08	 mov	 eax, DWORD PTR _Window$[ebp]
  00176	50		 push	 eax
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BeginPaint@8
  0017d	89 45 98	 mov	 DWORD PTR _DeviceContext$3[ebp], eax

; 401  : 		window_dimensions dimensions = Win32GetWindowDimensions(Window);

  00180	8b 4d 08	 mov	 ecx, DWORD PTR _Window$[ebp]
  00183	51		 push	 ecx
  00184	e8 00 00 00 00	 call	 ?Win32GetWindowDimensions@@YA?AUwindow_dimensions@@PAUHWND__@@@Z ; Win32GetWindowDimensions
  00189	83 c4 04	 add	 esp, 4
  0018c	89 45 90	 mov	 DWORD PTR $T2[ebp], eax
  0018f	89 55 94	 mov	 DWORD PTR $T2[ebp+4], edx
  00192	8b 55 90	 mov	 edx, DWORD PTR $T2[ebp]
  00195	8b 45 94	 mov	 eax, DWORD PTR $T2[ebp+4]
  00198	89 55 88	 mov	 DWORD PTR _dimensions$1[ebp], edx
  0019b	89 45 8c	 mov	 DWORD PTR _dimensions$1[ebp+4], eax

; 402  : 
; 403  : 		Win32DisplayBufferToWindow(

  0019e	8b 4d 8c	 mov	 ecx, DWORD PTR _dimensions$1[ebp+4]
  001a1	51		 push	 ecx
  001a2	8b 55 88	 mov	 edx, DWORD PTR _dimensions$1[ebp]
  001a5	52		 push	 edx
  001a6	8b 45 98	 mov	 eax, DWORD PTR _DeviceContext$3[ebp]
  001a9	50		 push	 eax
  001aa	68 00 00 00 00	 push	 OFFSET ?g_back_buffer@@3Uoffscreen_buffer@@A
  001af	e8 00 00 00 00	 call	 ?Win32DisplayBufferToWindow@@YAXPAUoffscreen_buffer@@PAUHDC__@@HH@Z ; Win32DisplayBufferToWindow
  001b4	83 c4 10	 add	 esp, 16			; 00000010H

; 404  : 			&g_back_buffer,
; 405  : 			DeviceContext,
; 406  : 			dimensions.width, dimensions.height);
; 407  : 		EndPaint(Window, &Paint);

  001b7	8d 4d bc	 lea	 ecx, DWORD PTR _Paint$8[ebp]
  001ba	51		 push	 ecx
  001bb	8b 55 08	 mov	 edx, DWORD PTR _Window$[ebp]
  001be	52		 push	 edx
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndPaint@8

; 408  : 	} break;

  001c5	eb 19		 jmp	 SHORT $LN2@Win32MainW
$LN40@Win32MainW:

; 409  : 
; 410  : 	default:
; 411  : 	{
; 412  : 		result = DefWindowProcA(Window, Message, WParam, LParam);

  001c7	8b 45 14	 mov	 eax, DWORD PTR _LParam$[ebp]
  001ca	50		 push	 eax
  001cb	8b 4d 10	 mov	 ecx, DWORD PTR _WParam$[ebp]
  001ce	51		 push	 ecx
  001cf	8b 55 0c	 mov	 edx, DWORD PTR _Message$[ebp]
  001d2	52		 push	 edx
  001d3	8b 45 08	 mov	 eax, DWORD PTR _Window$[ebp]
  001d6	50		 push	 eax
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  001dd	89 45 a0	 mov	 DWORD PTR _result$[ebp], eax
$LN2@Win32MainW:

; 413  : 	} break;
; 414  : 	}
; 415  : 
; 416  : 	return(result);

  001e0	8b 45 a0	 mov	 eax, DWORD PTR _result$[ebp]

; 417  : }

  001e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e6	33 cd		 xor	 ecx, ebp
  001e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ed	8b e5		 mov	 esp, ebp
  001ef	5d		 pop	 ebp
  001f0	c2 10 00	 ret	 16			; 00000010H
  001f3	90		 npad	 1
$LN48@Win32MainW:
  001f4	00 00 00 00	 DD	 $LN6@Win32MainW
  001f8	00 00 00 00	 DD	 $LN39@Win32MainW
  001fc	00 00 00 00	 DD	 $LN4@Win32MainW
  00200	00 00 00 00	 DD	 $LN5@Win32MainW
  00204	00 00 00 00	 DD	 $LN40@Win32MainW
$LN47@Win32MainW:
  00208	00		 DB	 0
  00209	04		 DB	 4
  0020a	04		 DB	 4
  0020b	04		 DB	 4
  0020c	04		 DB	 4
  0020d	04		 DB	 4
  0020e	04		 DB	 4
  0020f	04		 DB	 4
  00210	04		 DB	 4
  00211	04		 DB	 4
  00212	04		 DB	 4
  00213	04		 DB	 4
  00214	04		 DB	 4
  00215	01		 DB	 1
  00216	02		 DB	 2
  00217	04		 DB	 4
  00218	04		 DB	 4
  00219	04		 DB	 4
  0021a	04		 DB	 4
  0021b	04		 DB	 4
  0021c	04		 DB	 4
  0021d	04		 DB	 4
  0021e	04		 DB	 4
  0021f	04		 DB	 4
  00220	04		 DB	 4
  00221	04		 DB	 4
  00222	03		 DB	 3
?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z ENDP	; Win32MainWindowCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_DeviceContext$ = 12					; size = 4
_windowWidth$ = 16					; size = 4
_windowHeight$ = 20					; size = 4
?Win32DisplayBufferToWindow@@YAXPAUoffscreen_buffer@@PAUHDC__@@HH@Z PROC ; Win32DisplayBufferToWindow

; 293  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 294  : 	StretchDIBits(

  00003	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  00008	6a 00		 push	 0
  0000a	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00011	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00018	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0001f	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00022	50		 push	 eax
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	8b 4d 14	 mov	 ecx, DWORD PTR _windowHeight$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 10	 mov	 edx, DWORD PTR _windowWidth$[ebp]
  0002e	52		 push	 edx
  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	8b 45 0c	 mov	 eax, DWORD PTR _DeviceContext$[ebp]
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52

; 295  : 		DeviceContext,
; 296  : 		/* dest: x, y, width, height,
; 297  : 		   src:	 x, y, width, height,*/
; 298  : 		0, 0, windowWidth, windowHeight,
; 299  : 		0, 0, buffer->width, buffer->height,
; 300  : 		buffer->memory,
; 301  : 		&buffer->info,
; 302  : 		DIB_RGB_COLORS,
; 303  : 		SRCCOPY);
; 304  : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?Win32DisplayBufferToWindow@@YAXPAUoffscreen_buffer@@PAUHDC__@@HH@Z ENDP ; Win32DisplayBufferToWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_bitmapMemorySize$ = -8					; size = 4
_bytesPerPixel$ = -4					; size = 4
_buffer$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
?Win32ResizeDIBSection@@YAXPAUoffscreen_buffer@@HH@Z PROC ; Win32ResizeDIBSection

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 266  : 	if (buffer->memory)

  00006	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00009	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0000d	74 14		 je	 SHORT $LN2@Win32Resiz

; 267  : 	{
; 268  : 		VirtualFree(buffer->memory, 0, MEM_RELEASE);

  0000f	68 00 80 00 00	 push	 32768			; 00008000H
  00014	6a 00		 push	 0
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00019	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0001c	52		 push	 edx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualFree@12
$LN2@Win32Resiz:

; 269  : 	}
; 270  : 
; 271  : 	buffer->width = width;

  00023	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _width$[ebp]
  00029	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 272  : 	buffer->height = height;

  0002c	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0002f	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  00032	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 273  : 	int bytesPerPixel = 4;

  00035	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR _bytesPerPixel$[ebp], 4

; 274  : 
; 275  : 	buffer->info.bmiHeader.biSize = sizeof(buffer->info.bmiHeader);

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0003f	c7 01 28 00 00
	00		 mov	 DWORD PTR [ecx], 40	; 00000028H

; 276  : 	buffer->info.bmiHeader.biWidth = buffer->width;

  00045	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00048	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0004b	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0004e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 277  : 	buffer->info.bmiHeader.biHeight = -buffer->height;

  00051	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00054	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00057	f7 d8		 neg	 eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0005c	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 278  : 	buffer->info.bmiHeader.biPlanes = 1;

  0005f	ba 01 00 00 00	 mov	 edx, 1
  00064	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00067	66 89 50 0c	 mov	 WORD PTR [eax+12], dx

; 279  : 	buffer->info.bmiHeader.biBitCount = 32;

  0006b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00070	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00073	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx

; 280  : 	buffer->info.bmiHeader.biCompression = BI_RGB;

  00077	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0007a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 281  : 
; 282  : 	int bitmapMemorySize = (buffer->width * buffer->height) * bytesPerPixel;

  00081	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00084	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00087	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0008a	0f af 42 34	 imul	 eax, DWORD PTR [edx+52]
  0008e	0f af 45 fc	 imul	 eax, DWORD PTR _bytesPerPixel$[ebp]
  00092	89 45 f8	 mov	 DWORD PTR _bitmapMemorySize$[ebp], eax

; 283  : 	buffer->memory = VirtualAlloc(0, bitmapMemorySize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

  00095	6a 04		 push	 4
  00097	68 00 30 00 00	 push	 12288			; 00003000H
  0009c	8b 4d f8	 mov	 ecx, DWORD PTR _bitmapMemorySize$[ebp]
  0009f	51		 push	 ecx
  000a0	6a 00		 push	 0
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
  000a8	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  000ab	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 284  : 	buffer->pitch = width * bytesPerPixel;

  000ae	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  000b1	0f af 45 fc	 imul	 eax, DWORD PTR _bytesPerPixel$[ebp]
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000b8	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 285  : 
; 286  : }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
?Win32ResizeDIBSection@@YAXPAUoffscreen_buffer@@HH@Z ENDP ; Win32ResizeDIBSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_row$ = -20						; size = 4
_pixel$1 = -16						; size = 4
_y$2 = -12						; size = 4
_x$3 = -8						; size = 4
_red$4 = -3						; size = 1
_green$5 = -2						; size = 1
_blue$6 = -1						; size = 1
_buffer$ = 8						; size = 4
_blueOffset$ = 12					; size = 4
_greenOffset$ = 16					; size = 4
_redOffset$ = 20					; size = 4
?Win32RenderColor@@YAXPAUoffscreen_buffer@@HHH@Z PROC	; Win32RenderColor

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 242  : 
; 243  : 	uint8* row = (uint8*)buffer->memory;

  00006	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00009	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0000c	89 4d ec	 mov	 DWORD PTR _row$[ebp], ecx

; 244  : 	for (int y = 0; y < buffer->height; ++y)

  0000f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  00016	eb 09		 jmp	 SHORT $LN4@Win32Rende
$LN2@Win32Rende:
  00018	8b 55 f4	 mov	 edx, DWORD PTR _y$2[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 f4	 mov	 DWORD PTR _y$2[ebp], edx
$LN4@Win32Rende:
  00021	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00024	8b 4d f4	 mov	 ecx, DWORD PTR _y$2[ebp]
  00027	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  0002a	7d 72		 jge	 SHORT $LN1@Win32Rende

; 245  : 	{
; 246  : 		uint32* pixel = (uint32*)row;

  0002c	8b 55 ec	 mov	 edx, DWORD PTR _row$[ebp]
  0002f	89 55 f0	 mov	 DWORD PTR _pixel$1[ebp], edx

; 247  : 		for (int x = 0; x < buffer->width; ++x)

  00032	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$3[ebp], 0
  00039	eb 09		 jmp	 SHORT $LN7@Win32Rende
$LN5@Win32Rende:
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _x$3[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 f8	 mov	 DWORD PTR _x$3[ebp], eax
$LN7@Win32Rende:
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00047	8b 55 f8	 mov	 edx, DWORD PTR _x$3[ebp]
  0004a	3b 51 30	 cmp	 edx, DWORD PTR [ecx+48]
  0004d	7d 3e		 jge	 SHORT $LN6@Win32Rende

; 248  : 		{
; 249  : 			/*
; 250  : 			* Memory:	BB GG RR xx
; 251  : 			* Register:	xx RR GG BB
; 252  : 			*/
; 253  : 			uint8 blue = (x + blueOffset);

  0004f	8b 45 f8	 mov	 eax, DWORD PTR _x$3[ebp]
  00052	03 45 0c	 add	 eax, DWORD PTR _blueOffset$[ebp]
  00055	88 45 ff	 mov	 BYTE PTR _blue$6[ebp], al

; 254  : 			uint8 green = (y + greenOffset);

  00058	8b 4d f4	 mov	 ecx, DWORD PTR _y$2[ebp]
  0005b	03 4d 10	 add	 ecx, DWORD PTR _greenOffset$[ebp]
  0005e	88 4d fe	 mov	 BYTE PTR _green$5[ebp], cl

; 255  : 			uint8 red = (0 + redOffset);

  00061	8a 55 14	 mov	 dl, BYTE PTR _redOffset$[ebp]
  00064	88 55 fd	 mov	 BYTE PTR _red$4[ebp], dl

; 256  : 
; 257  : 			*pixel++ = (blue | (green << 8) | (red << 16));

  00067	0f b6 45 ff	 movzx	 eax, BYTE PTR _blue$6[ebp]
  0006b	0f b6 4d fe	 movzx	 ecx, BYTE PTR _green$5[ebp]
  0006f	c1 e1 08	 shl	 ecx, 8
  00072	0b c1		 or	 eax, ecx
  00074	0f b6 55 fd	 movzx	 edx, BYTE PTR _red$4[ebp]
  00078	c1 e2 10	 shl	 edx, 16			; 00000010H
  0007b	0b c2		 or	 eax, edx
  0007d	8b 4d f0	 mov	 ecx, DWORD PTR _pixel$1[ebp]
  00080	89 01		 mov	 DWORD PTR [ecx], eax
  00082	8b 55 f0	 mov	 edx, DWORD PTR _pixel$1[ebp]
  00085	83 c2 04	 add	 edx, 4
  00088	89 55 f0	 mov	 DWORD PTR _pixel$1[ebp], edx

; 258  : 		}

  0008b	eb ae		 jmp	 SHORT $LN5@Win32Rende
$LN6@Win32Rende:

; 259  : 
; 260  : 		row += buffer->pitch;

  0008d	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00090	8b 4d ec	 mov	 ecx, DWORD PTR _row$[ebp]
  00093	03 48 38	 add	 ecx, DWORD PTR [eax+56]
  00096	89 4d ec	 mov	 DWORD PTR _row$[ebp], ecx

; 261  : 	}

  00099	e9 7a ff ff ff	 jmp	 $LN2@Win32Rende
$LN1@Win32Rende:

; 262  : }

  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?Win32RenderColor@@YAXPAUoffscreen_buffer@@HHH@Z ENDP	; Win32RenderColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_result$ = -28						; size = 8
_ClientRect$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_Window$ = 8						; size = 4
?Win32GetWindowDimensions@@YA?AUwindow_dimensions@@PAUHWND__@@@Z PROC ; Win32GetWindowDimensions

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 230  : 	window_dimensions result;
; 231  : 
; 232  : 	RECT ClientRect;
; 233  : 	GetClientRect(Window, &ClientRect);

  00010	8d 45 ec	 lea	 eax, DWORD PTR _ClientRect$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _Window$[ebp]
  00017	51		 push	 ecx
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 234  : 	result.width = ClientRect.right - ClientRect.left;

  0001e	8b 55 f4	 mov	 edx, DWORD PTR _ClientRect$[ebp+8]
  00021	2b 55 ec	 sub	 edx, DWORD PTR _ClientRect$[ebp]
  00024	89 55 e4	 mov	 DWORD PTR _result$[ebp], edx

; 235  : 	result.height = ClientRect.bottom - ClientRect.top;

  00027	8b 45 f8	 mov	 eax, DWORD PTR _ClientRect$[ebp+12]
  0002a	2b 45 f0	 sub	 eax, DWORD PTR _ClientRect$[ebp+4]
  0002d	89 45 e8	 mov	 DWORD PTR _result$[ebp+4], eax

; 236  : 
; 237  : 	return(result);

  00030	8b 45 e4	 mov	 eax, DWORD PTR _result$[ebp]
  00033	8b 55 e8	 mov	 edx, DWORD PTR _result$[ebp+4]

; 238  : }

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00039	33 cd		 xor	 ecx, ebp
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?Win32GetWindowDimensions@@YA?AUwindow_dimensions@@PAUHWND__@@@Z ENDP ; Win32GetWindowDimensions
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_sineValue$1 = -52					; size = 4
_region2SampleCount$2 = -48				; size = 4
_sineValue$3 = -44					; size = 4
_region1SampleCount$4 = -40				; size = 4
_Region1$ = -36						; size = 4
_Region1Size$ = -32					; size = 4
_Region2$ = -28						; size = 4
_Region2Size$ = -24					; size = 4
_SampleIndex$5 = -20					; size = 4
_SampleIndex$6 = -16					; size = 4
_SampleOut$7 = -12					; size = 4
_sampleValue$8 = -8					; size = 2
_sampleValue$9 = -4					; size = 2
_soundOutput$ = 8					; size = 4
_byteToLock$ = 12					; size = 4
_bytesToWrite$ = 16					; size = 4
?Win32FillSoundBuffer@@YAXPAUsound_output@@KK@Z PROC	; Win32FillSoundBuffer

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 184  : 	VOID* Region1;
; 185  : 	DWORD Region1Size;
; 186  : 	VOID* Region2;
; 187  : 	DWORD Region2Size;
; 188  : 
; 189  : 	if (SUCCEEDED(g_secondary_buffer->Lock(

  00006	6a 00		 push	 0
  00008	8d 45 e8	 lea	 eax, DWORD PTR _Region2Size$[ebp]
  0000b	50		 push	 eax
  0000c	8d 4d e4	 lea	 ecx, DWORD PTR _Region2$[ebp]
  0000f	51		 push	 ecx
  00010	8d 55 e0	 lea	 edx, DWORD PTR _Region1Size$[ebp]
  00013	52		 push	 edx
  00014	8d 45 dc	 lea	 eax, DWORD PTR _Region1$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _bytesToWrite$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _byteToLock$[ebp]
  0001f	52		 push	 edx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  0002d	52		 push	 edx
  0002e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00031	ff d0		 call	 eax
  00033	85 c0		 test	 eax, eax
  00035	0f 8c a5 01 00
	00		 jl	 $LN8@Win32FillS

; 190  : 		byteToLock, bytesToWrite,
; 191  : 		&Region1, &Region1Size,
; 192  : 		&Region2, &Region2Size,
; 193  : 		0)))
; 194  : 	{
; 195  : 
; 196  : 		DWORD region1SampleCount = Region1Size / soundOutput->bytesPerSample;

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _soundOutput$[ebp]
  0003e	8b 45 e0	 mov	 eax, DWORD PTR _Region1Size$[ebp]
  00041	33 d2		 xor	 edx, edx
  00043	f7 71 14	 div	 DWORD PTR [ecx+20]
  00046	89 45 d8	 mov	 DWORD PTR _region1SampleCount$4[ebp], eax

; 197  : 		int16* SampleOut = (int16*)Region1;

  00049	8b 55 dc	 mov	 edx, DWORD PTR _Region1$[ebp]
  0004c	89 55 f4	 mov	 DWORD PTR _SampleOut$7[ebp], edx

; 198  : 		for (DWORD SampleIndex = 0; SampleIndex < region1SampleCount; ++SampleIndex)

  0004f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _SampleIndex$6[ebp], 0
  00056	eb 09		 jmp	 SHORT $LN4@Win32FillS
$LN2@Win32FillS:
  00058	8b 45 f0	 mov	 eax, DWORD PTR _SampleIndex$6[ebp]
  0005b	83 c0 01	 add	 eax, 1
  0005e	89 45 f0	 mov	 DWORD PTR _SampleIndex$6[ebp], eax
$LN4@Win32FillS:
  00061	8b 4d f0	 mov	 ecx, DWORD PTR _SampleIndex$6[ebp]
  00064	3b 4d d8	 cmp	 ecx, DWORD PTR _region1SampleCount$4[ebp]
  00067	0f 83 8f 00 00
	00		 jae	 $LN3@Win32FillS

; 199  : 		{
; 200  : 			real32 sineValue = sinf(soundOutput->tSine);

  0006d	8b 55 08	 mov	 edx, DWORD PTR _soundOutput$[ebp]
  00070	51		 push	 ecx
  00071	f3 0f 10 42 1c	 movss	 xmm0, DWORD PTR [edx+28]
  00076	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007b	e8 00 00 00 00	 call	 _sinf
  00080	83 c4 04	 add	 esp, 4
  00083	d9 5d d4	 fstp	 DWORD PTR _sineValue$3[ebp]

; 201  : 			int16 sampleValue = (int16)(sineValue * soundOutput->toneVolume);

  00086	8b 45 08	 mov	 eax, DWORD PTR _soundOutput$[ebp]
  00089	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0008d	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00091	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _sineValue$3[ebp]
  00096	f3 0f 2c d0	 cvttss2si edx, xmm0
  0009a	66 89 55 fc	 mov	 WORD PTR _sampleValue$9[ebp], dx

; 202  : 			*SampleOut++ = sampleValue;

  0009e	8b 45 f4	 mov	 eax, DWORD PTR _SampleOut$7[ebp]
  000a1	66 8b 4d fc	 mov	 cx, WORD PTR _sampleValue$9[ebp]
  000a5	66 89 08	 mov	 WORD PTR [eax], cx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _SampleOut$7[ebp]
  000ab	83 c2 02	 add	 edx, 2
  000ae	89 55 f4	 mov	 DWORD PTR _SampleOut$7[ebp], edx

; 203  : 			*SampleOut++ = sampleValue;

  000b1	8b 45 f4	 mov	 eax, DWORD PTR _SampleOut$7[ebp]
  000b4	66 8b 4d fc	 mov	 cx, WORD PTR _sampleValue$9[ebp]
  000b8	66 89 08	 mov	 WORD PTR [eax], cx
  000bb	8b 55 f4	 mov	 edx, DWORD PTR _SampleOut$7[ebp]
  000be	83 c2 02	 add	 edx, 2
  000c1	89 55 f4	 mov	 DWORD PTR _SampleOut$7[ebp], edx

; 204  : 
; 205  : 			soundOutput->tSine += (2.0f * pi32 * 1.0f) / ((real32)soundOutput->wavePeriod);

  000c4	8b 45 08	 mov	 eax, DWORD PTR _soundOutput$[ebp]
  000c7	f3 0f 2a 40 10	 cvtsi2ss xmm0, DWORD PTR [eax+16]
  000cc	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40c90fdb
  000d4	f3 0f 5e c8	 divss	 xmm1, xmm0
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _soundOutput$[ebp]
  000db	f3 0f 58 49 1c	 addss	 xmm1, DWORD PTR [ecx+28]
  000e0	8b 55 08	 mov	 edx, DWORD PTR _soundOutput$[ebp]
  000e3	f3 0f 11 4a 1c	 movss	 DWORD PTR [edx+28], xmm1

; 206  : 			++soundOutput->runningSampleIndex;

  000e8	8b 45 08	 mov	 eax, DWORD PTR _soundOutput$[ebp]
  000eb	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000ee	83 c1 01	 add	 ecx, 1
  000f1	8b 55 08	 mov	 edx, DWORD PTR _soundOutput$[ebp]
  000f4	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 207  : 		}

  000f7	e9 5c ff ff ff	 jmp	 $LN2@Win32FillS
$LN3@Win32FillS:

; 208  : 
; 209  : 		DWORD region2SampleCount = Region2Size / soundOutput->bytesPerSample;

  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _soundOutput$[ebp]
  000ff	8b 45 e8	 mov	 eax, DWORD PTR _Region2Size$[ebp]
  00102	33 d2		 xor	 edx, edx
  00104	f7 71 14	 div	 DWORD PTR [ecx+20]
  00107	89 45 d0	 mov	 DWORD PTR _region2SampleCount$2[ebp], eax

; 210  : 		SampleOut = (int16*)Region2;

  0010a	8b 55 e4	 mov	 edx, DWORD PTR _Region2$[ebp]
  0010d	89 55 f4	 mov	 DWORD PTR _SampleOut$7[ebp], edx

; 211  : 		for (DWORD SampleIndex = 0; SampleIndex < region2SampleCount; ++SampleIndex)

  00110	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _SampleIndex$5[ebp], 0
  00117	eb 09		 jmp	 SHORT $LN7@Win32FillS
$LN5@Win32FillS:
  00119	8b 45 ec	 mov	 eax, DWORD PTR _SampleIndex$5[ebp]
  0011c	83 c0 01	 add	 eax, 1
  0011f	89 45 ec	 mov	 DWORD PTR _SampleIndex$5[ebp], eax
$LN7@Win32FillS:
  00122	8b 4d ec	 mov	 ecx, DWORD PTR _SampleIndex$5[ebp]
  00125	3b 4d d0	 cmp	 ecx, DWORD PTR _region2SampleCount$2[ebp]
  00128	0f 83 8f 00 00
	00		 jae	 $LN6@Win32FillS

; 212  : 		{
; 213  : 			real32 sineValue = sinf(soundOutput->tSine);

  0012e	8b 55 08	 mov	 edx, DWORD PTR _soundOutput$[ebp]
  00131	51		 push	 ecx
  00132	f3 0f 10 42 1c	 movss	 xmm0, DWORD PTR [edx+28]
  00137	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013c	e8 00 00 00 00	 call	 _sinf
  00141	83 c4 04	 add	 esp, 4
  00144	d9 5d cc	 fstp	 DWORD PTR _sineValue$1[ebp]

; 214  : 			int16 sampleValue = (int16)(sineValue * soundOutput->toneVolume);

  00147	8b 45 08	 mov	 eax, DWORD PTR _soundOutput$[ebp]
  0014a	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0014e	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00152	f3 0f 59 45 cc	 mulss	 xmm0, DWORD PTR _sineValue$1[ebp]
  00157	f3 0f 2c d0	 cvttss2si edx, xmm0
  0015b	66 89 55 f8	 mov	 WORD PTR _sampleValue$8[ebp], dx

; 215  : 			*SampleOut++ = sampleValue;

  0015f	8b 45 f4	 mov	 eax, DWORD PTR _SampleOut$7[ebp]
  00162	66 8b 4d f8	 mov	 cx, WORD PTR _sampleValue$8[ebp]
  00166	66 89 08	 mov	 WORD PTR [eax], cx
  00169	8b 55 f4	 mov	 edx, DWORD PTR _SampleOut$7[ebp]
  0016c	83 c2 02	 add	 edx, 2
  0016f	89 55 f4	 mov	 DWORD PTR _SampleOut$7[ebp], edx

; 216  : 			*SampleOut++ = sampleValue;

  00172	8b 45 f4	 mov	 eax, DWORD PTR _SampleOut$7[ebp]
  00175	66 8b 4d f8	 mov	 cx, WORD PTR _sampleValue$8[ebp]
  00179	66 89 08	 mov	 WORD PTR [eax], cx
  0017c	8b 55 f4	 mov	 edx, DWORD PTR _SampleOut$7[ebp]
  0017f	83 c2 02	 add	 edx, 2
  00182	89 55 f4	 mov	 DWORD PTR _SampleOut$7[ebp], edx

; 217  : 
; 218  : 			soundOutput->tSine += (2.0f * pi32 * 1.0f) / ((real32)soundOutput->wavePeriod);

  00185	8b 45 08	 mov	 eax, DWORD PTR _soundOutput$[ebp]
  00188	f3 0f 2a 40 10	 cvtsi2ss xmm0, DWORD PTR [eax+16]
  0018d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40c90fdb
  00195	f3 0f 5e c8	 divss	 xmm1, xmm0
  00199	8b 4d 08	 mov	 ecx, DWORD PTR _soundOutput$[ebp]
  0019c	f3 0f 58 49 1c	 addss	 xmm1, DWORD PTR [ecx+28]
  001a1	8b 55 08	 mov	 edx, DWORD PTR _soundOutput$[ebp]
  001a4	f3 0f 11 4a 1c	 movss	 DWORD PTR [edx+28], xmm1

; 219  : 			++soundOutput->runningSampleIndex;

  001a9	8b 45 08	 mov	 eax, DWORD PTR _soundOutput$[ebp]
  001ac	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001af	83 c1 01	 add	 ecx, 1
  001b2	8b 55 08	 mov	 edx, DWORD PTR _soundOutput$[ebp]
  001b5	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 220  : 		}

  001b8	e9 5c ff ff ff	 jmp	 $LN5@Win32FillS
$LN6@Win32FillS:

; 221  : 
; 222  : 		g_secondary_buffer->Unlock(

  001bd	8b 45 e8	 mov	 eax, DWORD PTR _Region2Size$[ebp]
  001c0	50		 push	 eax
  001c1	8b 4d e4	 mov	 ecx, DWORD PTR _Region2$[ebp]
  001c4	51		 push	 ecx
  001c5	8b 55 e0	 mov	 edx, DWORD PTR _Region1Size$[ebp]
  001c8	52		 push	 edx
  001c9	8b 45 dc	 mov	 eax, DWORD PTR _Region1$[ebp]
  001cc	50		 push	 eax
  001cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  001d3	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  001da	50		 push	 eax
  001db	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  001de	ff d1		 call	 ecx
$LN8@Win32FillS:

; 223  : 			Region1, Region1Size,
; 224  : 			Region2, Region2Size);
; 225  : 	}
; 226  : }

  001e0	8b e5		 mov	 esp, ebp
  001e2	5d		 pop	 ebp
  001e3	c3		 ret	 0
?Win32FillSoundBuffer@@YAXPAUsound_output@@KK@Z ENDP	; Win32FillSoundBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_primaryBuffer$1 = -112					; size = 4
_DirectSoundCreate$2 = -108				; size = 4
_library$ = -104					; size = 4
_directSound$3 = -100					; size = 4
_bufferDescription$4 = -96				; size = 36
_bufferDescription$5 = -60				; size = 36
_waveFormat$6 = -24					; size = 18
__$ArrayPad$ = -4					; size = 4
_Window$ = 8						; size = 4
_samplesPerSecond$ = 12					; size = 4
_bufferSize$ = 16					; size = 4
?Win32InitDSound@@YAXPAUHWND__@@HH@Z PROC		; Win32InitDSound

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 112  : 	HMODULE library = LoadLibraryA("dsound.dll");

  00010	68 00 00 00 00	 push	 OFFSET $SG95375
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0001b	89 45 98	 mov	 DWORD PTR _library$[ebp], eax

; 113  : 	if (library)

  0001e	83 7d 98 00	 cmp	 DWORD PTR _library$[ebp], 0
  00022	0f 84 58 01 00
	00		 je	 $LN1@Win32InitD

; 114  : 	{
; 115  : 		direct_sound_create* DirectSoundCreate = (direct_sound_create*)GetProcAddress(library, "DirectSoundCreate");

  00028	68 00 00 00 00	 push	 OFFSET $SG95378
  0002d	8b 45 98	 mov	 eax, DWORD PTR _library$[ebp]
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00037	89 45 94	 mov	 DWORD PTR _DirectSoundCreate$2[ebp], eax

; 116  : 
; 117  : 		LPDIRECTSOUND directSound;
; 118  : 		if (DirectSoundCreate && SUCCEEDED(DirectSoundCreate(0, &directSound, 0)))

  0003a	83 7d 94 00	 cmp	 DWORD PTR _DirectSoundCreate$2[ebp], 0
  0003e	0f 84 3c 01 00
	00		 je	 $LN1@Win32InitD
  00044	6a 00		 push	 0
  00046	8d 4d 9c	 lea	 ecx, DWORD PTR _directSound$3[ebp]
  00049	51		 push	 ecx
  0004a	6a 00		 push	 0
  0004c	ff 55 94	 call	 DWORD PTR _DirectSoundCreate$2[ebp]
  0004f	85 c0		 test	 eax, eax
  00051	0f 8c 29 01 00
	00		 jl	 $LN1@Win32InitD

; 119  : 		{
; 120  : 			WAVEFORMATEX waveFormat;
; 121  : 			waveFormat.wFormatTag = WAVE_FORMAT_PCM;

  00057	ba 01 00 00 00	 mov	 edx, 1
  0005c	66 89 55 e8	 mov	 WORD PTR _waveFormat$6[ebp], dx

; 122  : 			waveFormat.nChannels = 2;

  00060	b8 02 00 00 00	 mov	 eax, 2
  00065	66 89 45 ea	 mov	 WORD PTR _waveFormat$6[ebp+2], ax

; 123  : 			waveFormat.nSamplesPerSec = samplesPerSecond;

  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _samplesPerSecond$[ebp]
  0006c	89 4d ec	 mov	 DWORD PTR _waveFormat$6[ebp+4], ecx

; 124  : 			waveFormat.wBitsPerSample = 16;

  0006f	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00074	66 89 55 f6	 mov	 WORD PTR _waveFormat$6[ebp+14], dx

; 125  : 			waveFormat.nBlockAlign = (waveFormat.nChannels * waveFormat.wBitsPerSample) / 8;

  00078	0f b7 45 ea	 movzx	 eax, WORD PTR _waveFormat$6[ebp+2]
  0007c	0f b7 4d f6	 movzx	 ecx, WORD PTR _waveFormat$6[ebp+14]
  00080	0f af c1	 imul	 eax, ecx
  00083	99		 cdq
  00084	83 e2 07	 and	 edx, 7
  00087	03 c2		 add	 eax, edx
  00089	c1 f8 03	 sar	 eax, 3
  0008c	66 89 45 f4	 mov	 WORD PTR _waveFormat$6[ebp+12], ax

; 126  : 			waveFormat.nAvgBytesPerSec = waveFormat.nSamplesPerSec * waveFormat.nBlockAlign;

  00090	0f b7 55 f4	 movzx	 edx, WORD PTR _waveFormat$6[ebp+12]
  00094	0f af 55 ec	 imul	 edx, DWORD PTR _waveFormat$6[ebp+4]
  00098	89 55 f0	 mov	 DWORD PTR _waveFormat$6[ebp+8], edx

; 127  : 			waveFormat.cbSize = 0;

  0009b	33 c0		 xor	 eax, eax
  0009d	66 89 45 f8	 mov	 WORD PTR _waveFormat$6[ebp+16], ax

; 128  : 
; 129  : 			if (SUCCEEDED(directSound->SetCooperativeLevel(Window, DSSCL_PRIORITY)))

  000a1	6a 02		 push	 2
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _Window$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 55 9c	 mov	 edx, DWORD PTR _directSound$3[ebp]
  000aa	8b 02		 mov	 eax, DWORD PTR [edx]
  000ac	8b 4d 9c	 mov	 ecx, DWORD PTR _directSound$3[ebp]
  000af	51		 push	 ecx
  000b0	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000b3	ff d2		 call	 edx
  000b5	85 c0		 test	 eax, eax
  000b7	7c 68		 jl	 SHORT $LN7@Win32InitD

; 130  : 			{
; 131  : 				DSBUFFERDESC bufferDescription = {};

  000b9	33 c0		 xor	 eax, eax
  000bb	89 45 c4	 mov	 DWORD PTR _bufferDescription$5[ebp], eax
  000be	89 45 c8	 mov	 DWORD PTR _bufferDescription$5[ebp+4], eax
  000c1	89 45 cc	 mov	 DWORD PTR _bufferDescription$5[ebp+8], eax
  000c4	89 45 d0	 mov	 DWORD PTR _bufferDescription$5[ebp+12], eax
  000c7	89 45 d4	 mov	 DWORD PTR _bufferDescription$5[ebp+16], eax
  000ca	89 45 d8	 mov	 DWORD PTR _bufferDescription$5[ebp+20], eax
  000cd	89 45 dc	 mov	 DWORD PTR _bufferDescription$5[ebp+24], eax
  000d0	89 45 e0	 mov	 DWORD PTR _bufferDescription$5[ebp+28], eax
  000d3	89 45 e4	 mov	 DWORD PTR _bufferDescription$5[ebp+32], eax

; 132  : 				bufferDescription.dwSize = sizeof(bufferDescription);

  000d6	c7 45 c4 24 00
	00 00		 mov	 DWORD PTR _bufferDescription$5[ebp], 36 ; 00000024H

; 133  : 				bufferDescription.dwFlags = DSBCAPS_PRIMARYBUFFER;

  000dd	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _bufferDescription$5[ebp+4], 1

; 134  : 				LPDIRECTSOUNDBUFFER primaryBuffer;
; 135  : 				if (SUCCEEDED(directSound->CreateSoundBuffer(&bufferDescription, &primaryBuffer, 0)))

  000e4	6a 00		 push	 0
  000e6	8d 4d 90	 lea	 ecx, DWORD PTR _primaryBuffer$1[ebp]
  000e9	51		 push	 ecx
  000ea	8d 55 c4	 lea	 edx, DWORD PTR _bufferDescription$5[ebp]
  000ed	52		 push	 edx
  000ee	8b 45 9c	 mov	 eax, DWORD PTR _directSound$3[ebp]
  000f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f3	8b 55 9c	 mov	 edx, DWORD PTR _directSound$3[ebp]
  000f6	52		 push	 edx
  000f7	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000fa	ff d0		 call	 eax
  000fc	85 c0		 test	 eax, eax
  000fe	7c 21		 jl	 SHORT $LN7@Win32InitD

; 136  : 				{
; 137  : 					if (SUCCEEDED(primaryBuffer->SetFormat(&waveFormat)))

  00100	8d 4d e8	 lea	 ecx, DWORD PTR _waveFormat$6[ebp]
  00103	51		 push	 ecx
  00104	8b 55 90	 mov	 edx, DWORD PTR _primaryBuffer$1[ebp]
  00107	8b 02		 mov	 eax, DWORD PTR [edx]
  00109	8b 4d 90	 mov	 ecx, DWORD PTR _primaryBuffer$1[ebp]
  0010c	51		 push	 ecx
  0010d	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  00110	ff d2		 call	 edx
  00112	85 c0		 test	 eax, eax
  00114	7c 0b		 jl	 SHORT $LN7@Win32InitD

; 138  : 					{
; 139  : 						OutputDebugStringA("Primary buffer format was set.\n");

  00116	68 00 00 00 00	 push	 OFFSET $SG95387
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
$LN7@Win32InitD:

; 140  : 					}
; 141  : 					else
; 142  : 					{
; 143  : 						// log diagnostic
; 144  : 					}
; 145  : 				}
; 146  : 				else
; 147  : 				{
; 148  : 					// log diagnostic
; 149  : 				}
; 150  : 			}
; 151  : 			else
; 152  : 			{
; 153  : 				// log diagnostic
; 154  : 			}
; 155  : 
; 156  : 			DSBUFFERDESC bufferDescription = {};

  00121	33 c0		 xor	 eax, eax
  00123	89 45 a0	 mov	 DWORD PTR _bufferDescription$4[ebp], eax
  00126	89 45 a4	 mov	 DWORD PTR _bufferDescription$4[ebp+4], eax
  00129	89 45 a8	 mov	 DWORD PTR _bufferDescription$4[ebp+8], eax
  0012c	89 45 ac	 mov	 DWORD PTR _bufferDescription$4[ebp+12], eax
  0012f	89 45 b0	 mov	 DWORD PTR _bufferDescription$4[ebp+16], eax
  00132	89 45 b4	 mov	 DWORD PTR _bufferDescription$4[ebp+20], eax
  00135	89 45 b8	 mov	 DWORD PTR _bufferDescription$4[ebp+24], eax
  00138	89 45 bc	 mov	 DWORD PTR _bufferDescription$4[ebp+28], eax
  0013b	89 45 c0	 mov	 DWORD PTR _bufferDescription$4[ebp+32], eax

; 157  : 			bufferDescription.dwSize = sizeof(bufferDescription);

  0013e	c7 45 a0 24 00
	00 00		 mov	 DWORD PTR _bufferDescription$4[ebp], 36 ; 00000024H

; 158  : 			bufferDescription.dwFlags = 0;

  00145	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _bufferDescription$4[ebp+4], 0

; 159  : 			bufferDescription.dwBufferBytes = bufferSize;

  0014c	8b 4d 10	 mov	 ecx, DWORD PTR _bufferSize$[ebp]
  0014f	89 4d a8	 mov	 DWORD PTR _bufferDescription$4[ebp+8], ecx

; 160  : 			bufferDescription.lpwfxFormat = &waveFormat;

  00152	8d 55 e8	 lea	 edx, DWORD PTR _waveFormat$6[ebp]
  00155	89 55 b0	 mov	 DWORD PTR _bufferDescription$4[ebp+16], edx

; 161  : 			if (SUCCEEDED(directSound->CreateSoundBuffer(&bufferDescription, &g_secondary_buffer, 0)))

  00158	6a 00		 push	 0
  0015a	68 00 00 00 00	 push	 OFFSET ?g_secondary_buffer@@3PAUIDirectSoundBuffer@@A
  0015f	8d 45 a0	 lea	 eax, DWORD PTR _bufferDescription$4[ebp]
  00162	50		 push	 eax
  00163	8b 4d 9c	 mov	 ecx, DWORD PTR _directSound$3[ebp]
  00166	8b 11		 mov	 edx, DWORD PTR [ecx]
  00168	8b 45 9c	 mov	 eax, DWORD PTR _directSound$3[ebp]
  0016b	50		 push	 eax
  0016c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0016f	ff d1		 call	 ecx
  00171	85 c0		 test	 eax, eax
  00173	7c 0b		 jl	 SHORT $LN1@Win32InitD

; 162  : 			{
; 163  : 				OutputDebugStringA("Primary buffer format was set.\n");

  00175	68 00 00 00 00	 push	 OFFSET $SG95390
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
$LN1@Win32InitD:

; 164  : 			}
; 165  : 			else
; 166  : 			{
; 167  : 				// log diagnostic
; 168  : 			}
; 169  : 		}
; 170  : 		else
; 171  : 		{
; 172  : 			// log diagnostic
; 173  : 		}
; 174  : 	}
; 175  : 	else
; 176  : 	{
; 177  : 		// log diagnostic
; 178  : 	}
; 179  : 
; 180  : }

  00180	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00183	33 cd		 xor	 ecx, ebp
  00185	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c3		 ret	 0
?Win32InitDSound@@YAXPAUHWND__@@HH@Z ENDP		; Win32InitDSound
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_library$ = -4						; size = 4
?Win32LoadXInput@@YAXXZ PROC				; Win32LoadXInput

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 88   : 	HMODULE library = LoadLibraryA("xinput1_4.dll");

  00004	68 00 00 00 00	 push	 OFFSET $SG95349
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0000f	89 45 fc	 mov	 DWORD PTR _library$[ebp], eax

; 89   : 	if (library)

  00012	83 7d fc 00	 cmp	 DWORD PTR _library$[ebp], 0
  00016	74 4e		 je	 SHORT $LN1@Win32LoadX

; 90   : 	{
; 91   : 		XInputGetState = (x_input_get_state*)GetProcAddress(library, "XInputGetState");

  00018	68 00 00 00 00	 push	 OFFSET $SG95352
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _library$[ebp]
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00027	a3 00 00 00 00	 mov	 DWORD PTR ?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA, eax

; 92   : 		if (!XInputGetState) {

  0002c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA, 0
  00033	75 0a		 jne	 SHORT $LN4@Win32LoadX

; 93   : 			XInputGetState = XInputGetStateStub;

  00035	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA, OFFSET ?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z ; XInputGetStateStub
$LN4@Win32LoadX:

; 94   : 		}
; 95   : 		xInputSetState_ = (x_input_set_state*)GetProcAddress(library, "XInputSetState");

  0003f	68 00 00 00 00	 push	 OFFSET $SG95354
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _library$[ebp]
  00047	51		 push	 ecx
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0004e	a3 00 00 00 00	 mov	 DWORD PTR ?xInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA, eax

; 96   : 		if (!XInputSetState) {

  00053	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?xInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA, 0
  0005a	75 0a		 jne	 SHORT $LN1@Win32LoadX

; 97   : 			XInputSetState = XInputSetStateStub;

  0005c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?xInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA, OFFSET ?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ; XInputSetStateStub
$LN1@Win32LoadX:

; 98   : 		}
; 99   : 		else
; 100  : 		{
; 101  : 			// log diagnostic
; 102  : 		}
; 103  : 	}
; 104  : 	else
; 105  : 	{
; 106  : 		// log diagnostic
; 107  : 	}
; 108  : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?Win32LoadXInput@@YAXXZ ENDP				; Win32LoadXInput
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_dwUserIndex$ = 8					; size = 4
_pVibration$ = 12					; size = 4
?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z PROC	; XInputSetStateStub

; 65   : XINPUT_SET_STATE(XInputSetStateStub) { return(ERROR_DEVICE_NOT_CONNECTED); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 8f 04 00 00	 mov	 eax, 1167		; 0000048fH
  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ENDP	; XInputSetStateStub
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_dwUserIndex$ = 8					; size = 4
_pState$ = 12						; size = 4
?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z PROC	; XInputGetStateStub

; 64   : XINPUT_GET_STATE(XInputGetStateStub) { return(ERROR_DEVICE_NOT_CONNECTED); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 8f 04 00 00	 mov	 eax, 1167		; 0000048fH
  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z ENDP	; XInputGetStateStub
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv71 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 757  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 758  :             return (float)sin(_X);

  00004	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00009	83 ec 08	 sub	 esp, 8
  0000c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00011	e8 00 00 00 00	 call	 _sin
  00016	83 c4 08	 add	 esp, 8
  00019	d9 5d fc	 fstp	 DWORD PTR tv71[ebp]
  0001c	d9 45 fc	 fld	 DWORD PTR tv71[ebp]

; 759  :         }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_Instance$ = 8						; size = 4
_PrevInstance$ = 12					; size = 4
_CmdLine$ = 16						; size = 4
_ShowCode$ = 20						; size = 4
_WinMain@16 PROC

; 587  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 588  : 	main(Instance);

  00003	8b 45 08	 mov	 eax, DWORD PTR _Instance$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _main
  0000c	83 c4 04	 add	 esp, 4

; 589  : 
; 590  : 	return(0);

  0000f	33 c0		 xor	 eax, eax

; 591  : }

  00011	5d		 pop	 ebp
  00012	c2 10 00	 ret	 16			; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
END
