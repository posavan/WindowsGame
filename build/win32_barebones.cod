; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33134.0 

	TITLE	W:\WindowsGame\build\win32_barebones.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z	; XInputGetStateStub
PUBLIC	?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ; XInputSetStateStub
CONST	SEGMENT
$SG94356 DB	'xinput1_4.dll', 00H
	ORG $+2
$SG94359 DB	'XInputGetState', 00H
	ORG $+1
$SG94361 DB	'XInputSetState', 00H
	ORG $+1
$SG94383 DB	'dsound.dll', 00H
	ORG $+1
$SG94386 DB	'DirectSoundCreate', 00H
	ORG $+2
$SG94455 DB	'WM_CLOSE', 0aH, 00H
	ORG $+2
$SG94457 DB	'WM_ACTIVATEAPP', 0aH, 00H
$SG94459 DB	'WM_DESTROY', 0aH, 00H
$SG94467 DB	'W: ', 00H
$SG94470 DB	'isDown ', 00H
$SG94472 DB	'wasDown ', 00H
	ORG $+3
$SG94473 DB	0aH, 00H
	ORG $+2
$SG94544 DB	'BareBonesWindowClass', 00H
	ORG $+3
$SG94547 DB	'Bare Bones', 00H
CONST	ENDS
PUBLIC	_WinMain@16
PUBLIC	_main
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__VirtualAlloc@16:PROC
EXTRN	__imp__VirtualFree@12:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__StretchDIBits@52:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?g_running@@3_NA DB 01H DUP (?)				; g_running
	ALIGN	4

?g_back_buffer@@3Uoffscreen_buffer@@A DB 03cH DUP (?)	; g_back_buffer
_BSS	ENDS
_DATA	SEGMENT
?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA DD FLAT:?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z ; xInputGetState_
?xInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA DD FLAT:?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ; xInputSetState_
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_main
	DD	010H
	DD	03d7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z
	DD	0dH
	DD	01e2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Win32GetWindowDimensions@@YA?AUwindow_dimensions@@PAUHWND__@@@Z
	DD	0dH
	DD	036H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Win32InitDSound@@YAXPAUHWND__@@HH@Z
	DD	0dH
	DD	0161H
voltbl	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_Message$1 = -188					; size = 28
_vibrate$2 = -160					; size = 4
_WindowClass$ = -156					; size = 40
_stickRY$3 = -116					; size = 2
_dimensions$4 = -112					; size = 8
$T5 = -104						; size = 8
_DeviceContext$6 = -96					; size = 4
_inputState$7 = -92					; size = 4
_stickRX$8 = -88					; size = 2
_dPadRight$9 = -81					; size = 1
_xOffset$10 = -80					; size = 4
_yOffset$11 = -76					; size = 4
_dPadLeft$12 = -71					; size = 1
_dPadDown$13 = -70					; size = 1
_dPadUp$14 = -69					; size = 1
_stickLY$15 = -68					; size = 2
_stickLX$16 = -64					; size = 2
_buttonY$17 = -58					; size = 1
_buttonX$18 = -57					; size = 1
_buttonB$19 = -56					; size = 1
_buttonA$20 = -55					; size = 1
_shoulderRight$21 = -54					; size = 1
_shoulderLeft$22 = -53					; size = 1
_thumbRight$23 = -52					; size = 1
_thumbLeft$24 = -51					; size = 1
_buttonBack$25 = -50					; size = 1
_buttonStart$26 = -49					; size = 1
_Window$27 = -48					; size = 4
_ctrlIndex$28 = -44					; size = 4
tv243 = -37						; size = 1
tv238 = -36						; size = 1
tv233 = -35						; size = 1
tv228 = -34						; size = 1
tv191 = -33						; size = 1
tv186 = -32						; size = 1
tv181 = -31						; size = 1
tv176 = -30						; size = 1
tv171 = -29						; size = 1
tv166 = -28						; size = 1
tv161 = -27						; size = 1
tv156 = -26						; size = 1
tv151 = -25						; size = 1
_pad$29 = -24						; size = 4
_state$30 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_Instance$ = 8						; size = 4
_main	PROC

; 355  : int main(HINSTANCE Instance) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec bc 00 00
	00		 sub	 esp, 188		; 000000bcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 356  : 	Win32LoadXInput();

  00013	e8 00 00 00 00	 call	 ?Win32LoadXInput@@YAXXZ	; Win32LoadXInput

; 357  : 
; 358  : 	WNDCLASSA WindowClass = {};

  00018	33 c0		 xor	 eax, eax
  0001a	89 85 64 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp], eax
  00020	89 85 68 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+4], eax
  00026	89 85 6c ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+8], eax
  0002c	89 85 70 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+12], eax
  00032	89 85 74 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+16], eax
  00038	89 85 78 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+20], eax
  0003e	89 85 7c ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+24], eax
  00044	89 45 80	 mov	 DWORD PTR _WindowClass$[ebp+28], eax
  00047	89 45 84	 mov	 DWORD PTR _WindowClass$[ebp+32], eax
  0004a	89 45 88	 mov	 DWORD PTR _WindowClass$[ebp+36], eax

; 359  : 
; 360  : 	Win32ResizeDIBSection(&g_back_buffer, 1280, 720);

  0004d	68 d0 02 00 00	 push	 720			; 000002d0H
  00052	68 00 05 00 00	 push	 1280			; 00000500H
  00057	68 00 00 00 00	 push	 OFFSET ?g_back_buffer@@3Uoffscreen_buffer@@A
  0005c	e8 00 00 00 00	 call	 ?Win32ResizeDIBSection@@YAXPAUoffscreen_buffer@@HH@Z ; Win32ResizeDIBSection
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 361  : 
; 362  : 	WindowClass.style = CS_HREDRAW | CS_VREDRAW;

  00064	c7 85 64 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp], 3

; 363  : 	WindowClass.lpfnWndProc = Win32MainWindowCallback;

  0006e	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp+4], OFFSET ?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z ; Win32MainWindowCallback

; 364  : 	WindowClass.hInstance = Instance;

  00078	8b 4d 08	 mov	 ecx, DWORD PTR _Instance$[ebp]
  0007b	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+16], ecx

; 365  : 	WindowClass.lpszClassName = "BareBonesWindowClass";

  00081	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _WindowClass$[ebp+36], OFFSET $SG94544

; 366  : 
; 367  : 	if (RegisterClassA(&WindowClass))

  00088	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR _WindowClass$[ebp]
  0008e	52		 push	 edx
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassA@4
  00095	0f b7 c0	 movzx	 eax, ax
  00098	85 c0		 test	 eax, eax
  0009a	0f 84 35 03 00
	00		 je	 $LN1@main

; 368  : 	{
; 369  : 		HWND Window = CreateWindowExA(

  000a0	6a 00		 push	 0
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _Instance$[ebp]
  000a5	51		 push	 ecx
  000a6	6a 00		 push	 0
  000a8	6a 00		 push	 0
  000aa	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000af	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000b4	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000b9	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000be	68 00 00 cf 10	 push	 282001408		; 10cf0000H
  000c3	68 00 00 00 00	 push	 OFFSET $SG94547
  000c8	8b 55 88	 mov	 edx, DWORD PTR _WindowClass$[ebp+36]
  000cb	52		 push	 edx
  000cc	6a 00		 push	 0
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  000d4	89 45 d0	 mov	 DWORD PTR _Window$27[ebp], eax

; 370  : 			0,
; 371  : 			WindowClass.lpszClassName,
; 372  : 			"Bare Bones",
; 373  : 			WS_OVERLAPPEDWINDOW | WS_VISIBLE,
; 374  : 			CW_USEDEFAULT,
; 375  : 			CW_USEDEFAULT,
; 376  : 			CW_USEDEFAULT,
; 377  : 			CW_USEDEFAULT,
; 378  : 			0,
; 379  : 			0,
; 380  : 			Instance,
; 381  : 			0);
; 382  : 		if (Window)

  000d7	83 7d d0 00	 cmp	 DWORD PTR _Window$27[ebp], 0
  000db	0f 84 f4 02 00
	00		 je	 $LN1@main

; 383  : 		{
; 384  : 			HDC DeviceContext = GetDC(Window);

  000e1	8b 45 d0	 mov	 eax, DWORD PTR _Window$27[ebp]
  000e4	50		 push	 eax
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  000eb	89 45 a0	 mov	 DWORD PTR _DeviceContext$6[ebp], eax

; 385  : 
; 386  : 			int xOffset = 0;

  000ee	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _xOffset$10[ebp], 0

; 387  : 			int yOffset = 0;

  000f5	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _yOffset$11[ebp], 0

; 388  : 
; 389  : 			Win32InitDSound(Window, 48000, 48000*sizeof(int16)*2);

  000fc	68 00 ee 02 00	 push	 192000			; 0002ee00H
  00101	68 80 bb 00 00	 push	 48000			; 0000bb80H
  00106	8b 4d d0	 mov	 ecx, DWORD PTR _Window$27[ebp]
  00109	51		 push	 ecx
  0010a	e8 00 00 00 00	 call	 ?Win32InitDSound@@YAXPAUHWND__@@HH@Z ; Win32InitDSound
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 390  : 
; 391  : 			g_running = true;

  00112	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?g_running@@3_NA, 1
$LN2@main:

; 392  : 			while (g_running)

  00119	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?g_running@@3_NA
  00120	85 d2		 test	 edx, edx
  00122	0f 84 ad 02 00
	00		 je	 $LN1@main
$LN4@main:

; 393  : 			{
; 394  : 				MSG Message;
; 395  : 				while (PeekMessage(&Message, 0, 0, 0, PM_REMOVE))

  00128	6a 01		 push	 1
  0012a	6a 00		 push	 0
  0012c	6a 00		 push	 0
  0012e	6a 00		 push	 0
  00130	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _Message$1[ebp]
  00136	50		 push	 eax
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  0013d	85 c0		 test	 eax, eax
  0013f	74 2c		 je	 SHORT $LN5@main

; 396  : 				{
; 397  : 					if (Message.message == WM_QUIT)

  00141	83 bd 48 ff ff
	ff 12		 cmp	 DWORD PTR _Message$1[ebp+4], 18 ; 00000012H
  00148	75 07		 jne	 SHORT $LN13@main

; 398  : 					{
; 399  : 						g_running = false;

  0014a	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?g_running@@3_NA, 0
$LN13@main:

; 400  : 					}
; 401  : 
; 402  : 					TranslateMessage(&Message);

  00151	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _Message$1[ebp]
  00157	51		 push	 ecx
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TranslateMessage@4

; 403  : 					DispatchMessageA(&Message);

  0015e	8d 95 44 ff ff
	ff		 lea	 edx, DWORD PTR _Message$1[ebp]
  00164	52		 push	 edx
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DispatchMessageA@4

; 404  : 				}

  0016b	eb bb		 jmp	 SHORT $LN4@main
$LN5@main:

; 405  : 
; 406  : 				for (DWORD ctrlIndex = 0; ctrlIndex < XUSER_MAX_COUNT; ++ctrlIndex)

  0016d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _ctrlIndex$28[ebp], 0
  00174	eb 09		 jmp	 SHORT $LN8@main
$LN6@main:
  00176	8b 45 d4	 mov	 eax, DWORD PTR _ctrlIndex$28[ebp]
  00179	83 c0 01	 add	 eax, 1
  0017c	89 45 d4	 mov	 DWORD PTR _ctrlIndex$28[ebp], eax
$LN8@main:
  0017f	83 7d d4 04	 cmp	 DWORD PTR _ctrlIndex$28[ebp], 4
  00183	0f 83 ec 01 00
	00		 jae	 $LN7@main

; 407  : 				{
; 408  : 					XINPUT_STATE state;
; 409  : 					DWORD inputState = XInputGetState(ctrlIndex, &state);

  00189	8d 4d ec	 lea	 ecx, DWORD PTR _state$30[ebp]
  0018c	51		 push	 ecx
  0018d	8b 55 d4	 mov	 edx, DWORD PTR _ctrlIndex$28[ebp]
  00190	52		 push	 edx
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR ?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA
  00197	89 45 a4	 mov	 DWORD PTR _inputState$7[ebp], eax

; 410  : 					if (inputState == ERROR_SUCCESS)

  0019a	83 7d a4 00	 cmp	 DWORD PTR _inputState$7[ebp], 0
  0019e	0f 85 cc 01 00
	00		 jne	 $LN15@main

; 411  : 					{
; 412  : 						// This controller is plugged in
; 413  : 						XINPUT_GAMEPAD* pad = &state.Gamepad;

  001a4	8d 45 f0	 lea	 eax, DWORD PTR _state$30[ebp+4]
  001a7	89 45 e8	 mov	 DWORD PTR _pad$29[ebp], eax

; 414  : 
; 415  : 						bool dPadUp = (pad->wButtons & XINPUT_GAMEPAD_DPAD_UP);

  001aa	8b 4d e8	 mov	 ecx, DWORD PTR _pad$29[ebp]
  001ad	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  001b0	83 e2 01	 and	 edx, 1
  001b3	88 55 bb	 mov	 BYTE PTR _dPadUp$14[ebp], dl

; 416  : 						bool dPadDown = (pad->wButtons & XINPUT_GAMEPAD_DPAD_DOWN);

  001b6	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  001b9	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001bc	83 e1 02	 and	 ecx, 2
  001bf	74 06		 je	 SHORT $LN17@main
  001c1	c6 45 e7 01	 mov	 BYTE PTR tv151[ebp], 1
  001c5	eb 04		 jmp	 SHORT $LN18@main
$LN17@main:
  001c7	c6 45 e7 00	 mov	 BYTE PTR tv151[ebp], 0
$LN18@main:
  001cb	8a 55 e7	 mov	 dl, BYTE PTR tv151[ebp]
  001ce	88 55 ba	 mov	 BYTE PTR _dPadDown$13[ebp], dl

; 417  : 						bool dPadLeft = (pad->wButtons & XINPUT_GAMEPAD_DPAD_LEFT);

  001d1	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  001d4	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001d7	83 e1 04	 and	 ecx, 4
  001da	74 06		 je	 SHORT $LN19@main
  001dc	c6 45 e6 01	 mov	 BYTE PTR tv156[ebp], 1
  001e0	eb 04		 jmp	 SHORT $LN20@main
$LN19@main:
  001e2	c6 45 e6 00	 mov	 BYTE PTR tv156[ebp], 0
$LN20@main:
  001e6	8a 55 e6	 mov	 dl, BYTE PTR tv156[ebp]
  001e9	88 55 b9	 mov	 BYTE PTR _dPadLeft$12[ebp], dl

; 418  : 						bool dPadRight = (pad->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT);

  001ec	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  001ef	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001f2	83 e1 08	 and	 ecx, 8
  001f5	74 06		 je	 SHORT $LN21@main
  001f7	c6 45 e5 01	 mov	 BYTE PTR tv161[ebp], 1
  001fb	eb 04		 jmp	 SHORT $LN22@main
$LN21@main:
  001fd	c6 45 e5 00	 mov	 BYTE PTR tv161[ebp], 0
$LN22@main:
  00201	8a 55 e5	 mov	 dl, BYTE PTR tv161[ebp]
  00204	88 55 af	 mov	 BYTE PTR _dPadRight$9[ebp], dl

; 419  : 						bool buttonStart = (pad->wButtons & XINPUT_GAMEPAD_START);

  00207	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  0020a	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0020d	83 e1 10	 and	 ecx, 16			; 00000010H
  00210	74 06		 je	 SHORT $LN23@main
  00212	c6 45 e4 01	 mov	 BYTE PTR tv166[ebp], 1
  00216	eb 04		 jmp	 SHORT $LN24@main
$LN23@main:
  00218	c6 45 e4 00	 mov	 BYTE PTR tv166[ebp], 0
$LN24@main:
  0021c	8a 55 e4	 mov	 dl, BYTE PTR tv166[ebp]
  0021f	88 55 cf	 mov	 BYTE PTR _buttonStart$26[ebp], dl

; 420  : 						bool buttonBack = (pad->wButtons & XINPUT_GAMEPAD_BACK);

  00222	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  00225	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00228	83 e1 20	 and	 ecx, 32			; 00000020H
  0022b	74 06		 je	 SHORT $LN25@main
  0022d	c6 45 e3 01	 mov	 BYTE PTR tv171[ebp], 1
  00231	eb 04		 jmp	 SHORT $LN26@main
$LN25@main:
  00233	c6 45 e3 00	 mov	 BYTE PTR tv171[ebp], 0
$LN26@main:
  00237	8a 55 e3	 mov	 dl, BYTE PTR tv171[ebp]
  0023a	88 55 ce	 mov	 BYTE PTR _buttonBack$25[ebp], dl

; 421  : 						bool thumbLeft = (pad->wButtons & XINPUT_GAMEPAD_LEFT_THUMB);

  0023d	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  00240	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00243	83 e1 40	 and	 ecx, 64			; 00000040H
  00246	74 06		 je	 SHORT $LN27@main
  00248	c6 45 e2 01	 mov	 BYTE PTR tv176[ebp], 1
  0024c	eb 04		 jmp	 SHORT $LN28@main
$LN27@main:
  0024e	c6 45 e2 00	 mov	 BYTE PTR tv176[ebp], 0
$LN28@main:
  00252	8a 55 e2	 mov	 dl, BYTE PTR tv176[ebp]
  00255	88 55 cd	 mov	 BYTE PTR _thumbLeft$24[ebp], dl

; 422  : 						bool thumbRight = (pad->wButtons & XINPUT_GAMEPAD_RIGHT_THUMB);

  00258	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  0025b	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0025e	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00264	74 06		 je	 SHORT $LN29@main
  00266	c6 45 e1 01	 mov	 BYTE PTR tv181[ebp], 1
  0026a	eb 04		 jmp	 SHORT $LN30@main
$LN29@main:
  0026c	c6 45 e1 00	 mov	 BYTE PTR tv181[ebp], 0
$LN30@main:
  00270	8a 55 e1	 mov	 dl, BYTE PTR tv181[ebp]
  00273	88 55 cc	 mov	 BYTE PTR _thumbRight$23[ebp], dl

; 423  : 						bool shoulderLeft = (pad->wButtons & XINPUT_GAMEPAD_LEFT_SHOULDER);

  00276	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  00279	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0027c	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  00282	74 06		 je	 SHORT $LN31@main
  00284	c6 45 e0 01	 mov	 BYTE PTR tv186[ebp], 1
  00288	eb 04		 jmp	 SHORT $LN32@main
$LN31@main:
  0028a	c6 45 e0 00	 mov	 BYTE PTR tv186[ebp], 0
$LN32@main:
  0028e	8a 55 e0	 mov	 dl, BYTE PTR tv186[ebp]
  00291	88 55 cb	 mov	 BYTE PTR _shoulderLeft$22[ebp], dl

; 424  : 						bool shoulderRight = (pad->wButtons & XINPUT_GAMEPAD_RIGHT_SHOULDER);

  00294	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  00297	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0029a	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  002a0	74 06		 je	 SHORT $LN33@main
  002a2	c6 45 df 01	 mov	 BYTE PTR tv191[ebp], 1
  002a6	eb 04		 jmp	 SHORT $LN34@main
$LN33@main:
  002a8	c6 45 df 00	 mov	 BYTE PTR tv191[ebp], 0
$LN34@main:
  002ac	8a 55 df	 mov	 dl, BYTE PTR tv191[ebp]
  002af	88 55 ca	 mov	 BYTE PTR _shoulderRight$21[ebp], dl

; 425  : 						bool buttonA = (pad->wButtons & XINPUT_GAMEPAD_A);

  002b2	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  002b5	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  002b8	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  002be	74 06		 je	 SHORT $LN35@main
  002c0	c6 45 de 01	 mov	 BYTE PTR tv228[ebp], 1
  002c4	eb 04		 jmp	 SHORT $LN36@main
$LN35@main:
  002c6	c6 45 de 00	 mov	 BYTE PTR tv228[ebp], 0
$LN36@main:
  002ca	8a 55 de	 mov	 dl, BYTE PTR tv228[ebp]
  002cd	88 55 c9	 mov	 BYTE PTR _buttonA$20[ebp], dl

; 426  : 						bool buttonB = (pad->wButtons & XINPUT_GAMEPAD_B);

  002d0	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  002d3	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  002d6	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  002dc	74 06		 je	 SHORT $LN37@main
  002de	c6 45 dd 01	 mov	 BYTE PTR tv233[ebp], 1
  002e2	eb 04		 jmp	 SHORT $LN38@main
$LN37@main:
  002e4	c6 45 dd 00	 mov	 BYTE PTR tv233[ebp], 0
$LN38@main:
  002e8	8a 55 dd	 mov	 dl, BYTE PTR tv233[ebp]
  002eb	88 55 c8	 mov	 BYTE PTR _buttonB$19[ebp], dl

; 427  : 						bool buttonX = (pad->wButtons & XINPUT_GAMEPAD_X);

  002ee	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  002f1	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  002f4	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  002fa	74 06		 je	 SHORT $LN39@main
  002fc	c6 45 dc 01	 mov	 BYTE PTR tv238[ebp], 1
  00300	eb 04		 jmp	 SHORT $LN40@main
$LN39@main:
  00302	c6 45 dc 00	 mov	 BYTE PTR tv238[ebp], 0
$LN40@main:
  00306	8a 55 dc	 mov	 dl, BYTE PTR tv238[ebp]
  00309	88 55 c7	 mov	 BYTE PTR _buttonX$18[ebp], dl

; 428  : 						bool buttonY = (pad->wButtons & XINPUT_GAMEPAD_Y);

  0030c	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  0030f	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00312	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  00318	74 06		 je	 SHORT $LN41@main
  0031a	c6 45 db 01	 mov	 BYTE PTR tv243[ebp], 1
  0031e	eb 04		 jmp	 SHORT $LN42@main
$LN41@main:
  00320	c6 45 db 00	 mov	 BYTE PTR tv243[ebp], 0
$LN42@main:
  00324	8a 55 db	 mov	 dl, BYTE PTR tv243[ebp]
  00327	88 55 c6	 mov	 BYTE PTR _buttonY$17[ebp], dl

; 429  : 
; 430  : 						int16 stickLX = pad->sThumbLX;

  0032a	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  0032d	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00331	66 89 4d c0	 mov	 WORD PTR _stickLX$16[ebp], cx

; 431  : 						int16 stickLY = pad->sThumbLY;

  00335	8b 55 e8	 mov	 edx, DWORD PTR _pad$29[ebp]
  00338	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  0033c	66 89 45 bc	 mov	 WORD PTR _stickLY$15[ebp], ax

; 432  : 						int16 stickRX = pad->sThumbRX;

  00340	8b 4d e8	 mov	 ecx, DWORD PTR _pad$29[ebp]
  00343	66 8b 51 08	 mov	 dx, WORD PTR [ecx+8]
  00347	66 89 55 a8	 mov	 WORD PTR _stickRX$8[ebp], dx

; 433  : 						int16 stickRY = pad->sThumbRY;

  0034b	8b 45 e8	 mov	 eax, DWORD PTR _pad$29[ebp]
  0034e	66 8b 48 0a	 mov	 cx, WORD PTR [eax+10]
  00352	66 89 4d 8c	 mov	 WORD PTR _stickRY$3[ebp], cx

; 434  : 
; 435  : 						xOffset += stickLX >> 12;

  00356	0f bf 55 c0	 movsx	 edx, WORD PTR _stickLX$16[ebp]
  0035a	c1 fa 0c	 sar	 edx, 12			; 0000000cH
  0035d	03 55 b0	 add	 edx, DWORD PTR _xOffset$10[ebp]
  00360	89 55 b0	 mov	 DWORD PTR _xOffset$10[ebp], edx

; 436  : 						yOffset += stickLY >> 12;

  00363	0f bf 45 bc	 movsx	 eax, WORD PTR _stickLY$15[ebp]
  00367	c1 f8 0c	 sar	 eax, 12			; 0000000cH
  0036a	03 45 b4	 add	 eax, DWORD PTR _yOffset$11[ebp]
  0036d	89 45 b4	 mov	 DWORD PTR _yOffset$11[ebp], eax
$LN15@main:

; 437  : 					}
; 438  : 					else
; 439  : 					{
; 440  : 						// This controller is not available
; 441  : 					}
; 442  : 				}

  00370	e9 01 fe ff ff	 jmp	 $LN6@main
$LN7@main:

; 443  : 
; 444  : 				//add rumble
; 445  : 				XINPUT_VIBRATION vibrate;
; 446  : 				//vibrate.wLeftMotorSpeed = 50000;
; 447  : 				//vibrate.wRightMotorSpeed = 50000;
; 448  : 				XInputSetState(0, &vibrate);

  00375	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _vibrate$2[ebp]
  0037b	51		 push	 ecx
  0037c	6a 00		 push	 0
  0037e	ff 15 00 00 00
	00		 call	 DWORD PTR ?xInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA

; 449  : 
; 450  : 				Win32RenderColor(&g_back_buffer, xOffset, yOffset);

  00384	8b 55 b4	 mov	 edx, DWORD PTR _yOffset$11[ebp]
  00387	52		 push	 edx
  00388	8b 45 b0	 mov	 eax, DWORD PTR _xOffset$10[ebp]
  0038b	50		 push	 eax
  0038c	68 00 00 00 00	 push	 OFFSET ?g_back_buffer@@3Uoffscreen_buffer@@A
  00391	e8 00 00 00 00	 call	 ?Win32RenderColor@@YAXPAUoffscreen_buffer@@HH@Z ; Win32RenderColor
  00396	83 c4 0c	 add	 esp, 12			; 0000000cH

; 451  : 				window_dimensions dimensions = Win32GetWindowDimensions(Window);

  00399	8b 4d d0	 mov	 ecx, DWORD PTR _Window$27[ebp]
  0039c	51		 push	 ecx
  0039d	e8 00 00 00 00	 call	 ?Win32GetWindowDimensions@@YA?AUwindow_dimensions@@PAUHWND__@@@Z ; Win32GetWindowDimensions
  003a2	83 c4 04	 add	 esp, 4
  003a5	89 45 98	 mov	 DWORD PTR $T5[ebp], eax
  003a8	89 55 9c	 mov	 DWORD PTR $T5[ebp+4], edx
  003ab	8b 55 98	 mov	 edx, DWORD PTR $T5[ebp]
  003ae	8b 45 9c	 mov	 eax, DWORD PTR $T5[ebp+4]
  003b1	89 55 90	 mov	 DWORD PTR _dimensions$4[ebp], edx
  003b4	89 45 94	 mov	 DWORD PTR _dimensions$4[ebp+4], eax

; 452  : 				Win32DisplayBufferToWindow(

  003b7	8b 4d 94	 mov	 ecx, DWORD PTR _dimensions$4[ebp+4]
  003ba	51		 push	 ecx
  003bb	8b 55 90	 mov	 edx, DWORD PTR _dimensions$4[ebp]
  003be	52		 push	 edx
  003bf	8b 45 a0	 mov	 eax, DWORD PTR _DeviceContext$6[ebp]
  003c2	50		 push	 eax
  003c3	68 00 00 00 00	 push	 OFFSET ?g_back_buffer@@3Uoffscreen_buffer@@A
  003c8	e8 00 00 00 00	 call	 ?Win32DisplayBufferToWindow@@YAXPAUoffscreen_buffer@@PAUHDC__@@HH@Z ; Win32DisplayBufferToWindow
  003cd	83 c4 10	 add	 esp, 16			; 00000010H

; 453  : 					&g_back_buffer,
; 454  : 					DeviceContext,
; 455  : 					dimensions.width, dimensions.height);
; 456  : 
; 457  : 			}

  003d0	e9 44 fd ff ff	 jmp	 $LN2@main
$LN1@main:

; 458  : 		}
; 459  : 		else
; 460  : 		{
; 461  : 			//log
; 462  : 		}
; 463  : 	}
; 464  : 	else
; 465  : 	{
; 466  : 		//log
; 467  : 	}
; 468  : 
; 469  : }

  003d5	33 c0		 xor	 eax, eax
  003d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003da	33 cd		 xor	 ecx, ebp
  003dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003e1	8b e5		 mov	 esp, ebp
  003e3	5d		 pop	 ebp
  003e4	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_dimensions$1 = -116					; size = 8
$T2 = -108						; size = 8
_DeviceContext$3 = -100					; size = 4
_AltKeyDown$4 = -96					; size = 4
_result$ = -92						; size = 4
tv74 = -88						; size = 4
tv70 = -84						; size = 4
tv64 = -80						; size = 4
_wasDown$5 = -74					; size = 1
_isDown$6 = -73						; size = 1
_VKCode$7 = -72						; size = 4
_Paint$8 = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_Window$ = 8						; size = 4
_Message$ = 12						; size = 4
_WParam$ = 16						; size = 4
_LParam$ = 20						; size = 4
?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z PROC	; Win32MainWindowCallback

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 248  : 	LRESULT result = 0;

  00010	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 249  : 
; 250  : 	switch (Message)

  00017	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  0001a	89 45 b0	 mov	 DWORD PTR tv64[ebp], eax
  0001d	81 7d b0 00 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 256 ; 00000100H
  00024	77 31		 ja	 SHORT $LN46@Win32MainW
  00026	81 7d b0 00 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 256 ; 00000100H
  0002d	0f 84 82 00 00
	00		 je	 $LN10@Win32MainW
  00033	8b 4d b0	 mov	 ecx, DWORD PTR tv64[ebp]
  00036	83 e9 02	 sub	 ecx, 2
  00039	89 4d b0	 mov	 DWORD PTR tv64[ebp], ecx
  0003c	83 7d b0 1a	 cmp	 DWORD PTR tv64[ebp], 26	; 0000001aH
  00040	0f 87 80 01 00
	00		 ja	 $LN40@Win32MainW
  00046	8b 55 b0	 mov	 edx, DWORD PTR tv64[ebp]
  00049	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN47@Win32MainW[edx]
  00050	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN48@Win32MainW[eax*4]
$LN46@Win32MainW:
  00057	81 7d b0 01 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 257 ; 00000101H
  0005e	74 55		 je	 SHORT $LN10@Win32MainW
  00060	81 7d b0 04 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 260 ; 00000104H
  00067	74 4c		 je	 SHORT $LN10@Win32MainW
  00069	81 7d b0 05 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 261 ; 00000105H
  00070	74 43		 je	 SHORT $LN10@Win32MainW
  00072	e9 4f 01 00 00	 jmp	 $LN40@Win32MainW
$LN4@Win32MainW:

; 251  : 	{
; 252  : 	case WM_CLOSE:
; 253  : 	{
; 254  : 		g_running = false;

  00077	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?g_running@@3_NA, 0

; 255  : 		OutputDebugStringA("WM_CLOSE\n");

  0007e	68 00 00 00 00	 push	 OFFSET $SG94455
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 256  : 	} break;

  00089	e9 51 01 00 00	 jmp	 $LN2@Win32MainW
$LN5@Win32MainW:

; 257  : 	case WM_ACTIVATEAPP:
; 258  : 	{
; 259  : 		OutputDebugStringA("WM_ACTIVATEAPP\n");

  0008e	68 00 00 00 00	 push	 OFFSET $SG94457
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 260  : 	} break;

  00099	e9 41 01 00 00	 jmp	 $LN2@Win32MainW
$LN6@Win32MainW:

; 261  : 	case WM_DESTROY:
; 262  : 	{
; 263  : 		g_running = false;

  0009e	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?g_running@@3_NA, 0

; 264  : 		OutputDebugStringA("WM_DESTROY\n");

  000a5	68 00 00 00 00	 push	 OFFSET $SG94459
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 265  : 	} break;

  000b0	e9 2a 01 00 00	 jmp	 $LN2@Win32MainW
$LN10@Win32MainW:

; 266  : 
; 267  : 	case WM_SYSKEYDOWN:
; 268  : 	case WM_SYSKEYUP:
; 269  : 	case WM_KEYDOWN:
; 270  : 	case WM_KEYUP:
; 271  : 	{
; 272  : 		uint32 VKCode = WParam;

  000b5	8b 4d 10	 mov	 ecx, DWORD PTR _WParam$[ebp]
  000b8	89 4d b8	 mov	 DWORD PTR _VKCode$7[ebp], ecx

; 273  : 		bool wasDown = ((LParam & (1 << 30)) != 0);

  000bb	8b 55 14	 mov	 edx, DWORD PTR _LParam$[ebp]
  000be	81 e2 00 00 00
	40		 and	 edx, 1073741824		; 40000000H
  000c4	74 09		 je	 SHORT $LN42@Win32MainW
  000c6	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  000cd	eb 07		 jmp	 SHORT $LN43@Win32MainW
$LN42@Win32MainW:
  000cf	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN43@Win32MainW:
  000d6	8a 45 ac	 mov	 al, BYTE PTR tv70[ebp]
  000d9	88 45 b6	 mov	 BYTE PTR _wasDown$5[ebp], al

; 274  : 		bool isDown = ((LParam & (1 << 31)) == 0);

  000dc	8b 4d 14	 mov	 ecx, DWORD PTR _LParam$[ebp]
  000df	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  000e5	75 09		 jne	 SHORT $LN44@Win32MainW
  000e7	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  000ee	eb 07		 jmp	 SHORT $LN45@Win32MainW
$LN44@Win32MainW:
  000f0	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN45@Win32MainW:
  000f7	8a 55 a8	 mov	 dl, BYTE PTR tv74[ebp]
  000fa	88 55 b7	 mov	 BYTE PTR _isDown$6[ebp], dl

; 275  : 		if (wasDown != isDown)

  000fd	0f b6 45 b6	 movzx	 eax, BYTE PTR _wasDown$5[ebp]
  00101	0f b6 4d b7	 movzx	 ecx, BYTE PTR _isDown$6[ebp]
  00105	3b c1		 cmp	 eax, ecx
  00107	74 44		 je	 SHORT $LN11@Win32MainW

; 276  : 		{
; 277  : 			if (VKCode == 'W')

  00109	83 7d b8 57	 cmp	 DWORD PTR _VKCode$7[ebp], 87 ; 00000057H
  0010d	75 3e		 jne	 SHORT $LN11@Win32MainW

; 278  : 			{
; 279  : 				OutputDebugStringA("W: ");

  0010f	68 00 00 00 00	 push	 OFFSET $SG94467
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 280  : 				if (isDown)

  0011a	0f b6 55 b7	 movzx	 edx, BYTE PTR _isDown$6[ebp]
  0011e	85 d2		 test	 edx, edx
  00120	74 0d		 je	 SHORT $LN14@Win32MainW

; 281  : 				{
; 282  : 					OutputDebugStringA("isDown ");

  00122	68 00 00 00 00	 push	 OFFSET $SG94470
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 283  : 				}

  0012d	eb 13		 jmp	 SHORT $LN15@Win32MainW
$LN14@Win32MainW:

; 284  : 				else if (wasDown)

  0012f	0f b6 45 b6	 movzx	 eax, BYTE PTR _wasDown$5[ebp]
  00133	85 c0		 test	 eax, eax
  00135	74 0b		 je	 SHORT $LN15@Win32MainW

; 285  : 				{
; 286  : 					OutputDebugStringA("wasDown ");

  00137	68 00 00 00 00	 push	 OFFSET $SG94472
  0013c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
$LN15@Win32MainW:

; 287  : 				}
; 288  : 				OutputDebugStringA("\n");

  00142	68 00 00 00 00	 push	 OFFSET $SG94473
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
$LN11@Win32MainW:

; 289  : 			}
; 290  : 			else if (VKCode == 'A')
; 291  : 			{
; 292  : 			}
; 293  : 			else if (VKCode == 'S')
; 294  : 			{
; 295  : 			}
; 296  : 			else if (VKCode == 'D')
; 297  : 			{
; 298  : 			}
; 299  : 			else if (VKCode == 'Q')
; 300  : 			{
; 301  : 			}
; 302  : 			else if (VKCode == 'E')
; 303  : 			{
; 304  : 			}
; 305  : 			else if (VKCode == VK_UP)
; 306  : 			{
; 307  : 			}
; 308  : 			else if (VKCode == VK_LEFT)
; 309  : 			{
; 310  : 			}
; 311  : 			else if (VKCode == VK_DOWN)
; 312  : 			{
; 313  : 			}
; 314  : 			else if (VKCode == VK_RIGHT)
; 315  : 			{
; 316  : 			}
; 317  : 			else if (VKCode == VK_ESCAPE)
; 318  : 			{
; 319  : 			}
; 320  : 			else if (VKCode == VK_SPACE)
; 321  : 			{
; 322  : 			}
; 323  : 		}
; 324  : 
; 325  : 		bool32 AltKeyDown = (LParam & (1 << 29));

  0014d	8b 4d 14	 mov	 ecx, DWORD PTR _LParam$[ebp]
  00150	81 e1 00 00 00
	20		 and	 ecx, 536870912		; 20000000H
  00156	89 4d a0	 mov	 DWORD PTR _AltKeyDown$4[ebp], ecx

; 326  : 		if ((VKCode == VK_F4) && AltKeyDown) 

  00159	83 7d b8 73	 cmp	 DWORD PTR _VKCode$7[ebp], 115 ; 00000073H
  0015d	75 0d		 jne	 SHORT $LN38@Win32MainW
  0015f	83 7d a0 00	 cmp	 DWORD PTR _AltKeyDown$4[ebp], 0
  00163	74 07		 je	 SHORT $LN38@Win32MainW

; 327  : 		{ 
; 328  : 			g_running = false; 

  00165	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?g_running@@3_NA, 0
$LN38@Win32MainW:

; 329  : 		}
; 330  : 
; 331  : 	} break;

  0016c	eb 71		 jmp	 SHORT $LN2@Win32MainW
$LN39@Win32MainW:

; 332  : 
; 333  : 	case WM_PAINT:
; 334  : 	{
; 335  : 		PAINTSTRUCT Paint;
; 336  : 		HDC DeviceContext = BeginPaint(Window, &Paint);

  0016e	8d 55 bc	 lea	 edx, DWORD PTR _Paint$8[ebp]
  00171	52		 push	 edx
  00172	8b 45 08	 mov	 eax, DWORD PTR _Window$[ebp]
  00175	50		 push	 eax
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BeginPaint@8
  0017c	89 45 9c	 mov	 DWORD PTR _DeviceContext$3[ebp], eax

; 337  : 		window_dimensions dimensions = Win32GetWindowDimensions(Window);

  0017f	8b 4d 08	 mov	 ecx, DWORD PTR _Window$[ebp]
  00182	51		 push	 ecx
  00183	e8 00 00 00 00	 call	 ?Win32GetWindowDimensions@@YA?AUwindow_dimensions@@PAUHWND__@@@Z ; Win32GetWindowDimensions
  00188	83 c4 04	 add	 esp, 4
  0018b	89 45 94	 mov	 DWORD PTR $T2[ebp], eax
  0018e	89 55 98	 mov	 DWORD PTR $T2[ebp+4], edx
  00191	8b 55 94	 mov	 edx, DWORD PTR $T2[ebp]
  00194	8b 45 98	 mov	 eax, DWORD PTR $T2[ebp+4]
  00197	89 55 8c	 mov	 DWORD PTR _dimensions$1[ebp], edx
  0019a	89 45 90	 mov	 DWORD PTR _dimensions$1[ebp+4], eax

; 338  : 
; 339  : 		Win32DisplayBufferToWindow(

  0019d	8b 4d 90	 mov	 ecx, DWORD PTR _dimensions$1[ebp+4]
  001a0	51		 push	 ecx
  001a1	8b 55 8c	 mov	 edx, DWORD PTR _dimensions$1[ebp]
  001a4	52		 push	 edx
  001a5	8b 45 9c	 mov	 eax, DWORD PTR _DeviceContext$3[ebp]
  001a8	50		 push	 eax
  001a9	68 00 00 00 00	 push	 OFFSET ?g_back_buffer@@3Uoffscreen_buffer@@A
  001ae	e8 00 00 00 00	 call	 ?Win32DisplayBufferToWindow@@YAXPAUoffscreen_buffer@@PAUHDC__@@HH@Z ; Win32DisplayBufferToWindow
  001b3	83 c4 10	 add	 esp, 16			; 00000010H

; 340  : 			&g_back_buffer,
; 341  : 			DeviceContext,
; 342  : 			dimensions.width, dimensions.height);
; 343  : 		EndPaint(Window, &Paint);

  001b6	8d 4d bc	 lea	 ecx, DWORD PTR _Paint$8[ebp]
  001b9	51		 push	 ecx
  001ba	8b 55 08	 mov	 edx, DWORD PTR _Window$[ebp]
  001bd	52		 push	 edx
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndPaint@8

; 344  : 	} break;

  001c4	eb 19		 jmp	 SHORT $LN2@Win32MainW
$LN40@Win32MainW:

; 345  : 
; 346  : 	default:
; 347  : 	{
; 348  : 		result = DefWindowProcA(Window, Message, WParam, LParam);

  001c6	8b 45 14	 mov	 eax, DWORD PTR _LParam$[ebp]
  001c9	50		 push	 eax
  001ca	8b 4d 10	 mov	 ecx, DWORD PTR _WParam$[ebp]
  001cd	51		 push	 ecx
  001ce	8b 55 0c	 mov	 edx, DWORD PTR _Message$[ebp]
  001d1	52		 push	 edx
  001d2	8b 45 08	 mov	 eax, DWORD PTR _Window$[ebp]
  001d5	50		 push	 eax
  001d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  001dc	89 45 a4	 mov	 DWORD PTR _result$[ebp], eax
$LN2@Win32MainW:

; 349  : 	} break;
; 350  : 	}
; 351  : 
; 352  : 	return(result);

  001df	8b 45 a4	 mov	 eax, DWORD PTR _result$[ebp]

; 353  : }

  001e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e5	33 cd		 xor	 ecx, ebp
  001e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c2 10 00	 ret	 16			; 00000010H
  001f2	66 90		 npad	 2
$LN48@Win32MainW:
  001f4	00 00 00 00	 DD	 $LN6@Win32MainW
  001f8	00 00 00 00	 DD	 $LN39@Win32MainW
  001fc	00 00 00 00	 DD	 $LN4@Win32MainW
  00200	00 00 00 00	 DD	 $LN5@Win32MainW
  00204	00 00 00 00	 DD	 $LN40@Win32MainW
$LN47@Win32MainW:
  00208	00		 DB	 0
  00209	04		 DB	 4
  0020a	04		 DB	 4
  0020b	04		 DB	 4
  0020c	04		 DB	 4
  0020d	04		 DB	 4
  0020e	04		 DB	 4
  0020f	04		 DB	 4
  00210	04		 DB	 4
  00211	04		 DB	 4
  00212	04		 DB	 4
  00213	04		 DB	 4
  00214	04		 DB	 4
  00215	01		 DB	 1
  00216	02		 DB	 2
  00217	04		 DB	 4
  00218	04		 DB	 4
  00219	04		 DB	 4
  0021a	04		 DB	 4
  0021b	04		 DB	 4
  0021c	04		 DB	 4
  0021d	04		 DB	 4
  0021e	04		 DB	 4
  0021f	04		 DB	 4
  00220	04		 DB	 4
  00221	04		 DB	 4
  00222	03		 DB	 3
?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z ENDP	; Win32MainWindowCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_DeviceContext$ = 12					; size = 4
_windowWidth$ = 16					; size = 4
_windowHeight$ = 20					; size = 4
?Win32DisplayBufferToWindow@@YAXPAUoffscreen_buffer@@PAUHDC__@@HH@Z PROC ; Win32DisplayBufferToWindow

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 230  : 	StretchDIBits(

  00003	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  00008	6a 00		 push	 0
  0000a	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00011	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00018	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0001f	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00022	50		 push	 eax
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	8b 4d 14	 mov	 ecx, DWORD PTR _windowHeight$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 10	 mov	 edx, DWORD PTR _windowWidth$[ebp]
  0002e	52		 push	 edx
  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	8b 45 0c	 mov	 eax, DWORD PTR _DeviceContext$[ebp]
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52

; 231  : 		DeviceContext,
; 232  : 		/* dest: x, y, width, height,
; 233  : 		   src:	 x, y, width, height,*/
; 234  : 		0, 0, windowWidth, windowHeight,
; 235  : 		0, 0, buffer->width, buffer->height,
; 236  : 		buffer->memory,
; 237  : 		&buffer->info,
; 238  : 		DIB_RGB_COLORS,
; 239  : 		SRCCOPY);
; 240  : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?Win32DisplayBufferToWindow@@YAXPAUoffscreen_buffer@@PAUHDC__@@HH@Z ENDP ; Win32DisplayBufferToWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_bitmapMemorySize$ = -8					; size = 4
_bytesPerPixel$ = -4					; size = 4
_buffer$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
?Win32ResizeDIBSection@@YAXPAUoffscreen_buffer@@HH@Z PROC ; Win32ResizeDIBSection

; 201  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 202  : 	if (buffer->memory)

  00006	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00009	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0000d	74 14		 je	 SHORT $LN2@Win32Resiz

; 203  : 	{
; 204  : 		VirtualFree(buffer->memory, 0, MEM_RELEASE);

  0000f	68 00 80 00 00	 push	 32768			; 00008000H
  00014	6a 00		 push	 0
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00019	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0001c	52		 push	 edx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualFree@12
$LN2@Win32Resiz:

; 205  : 	}
; 206  : 
; 207  : 	buffer->width = width;

  00023	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _width$[ebp]
  00029	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 208  : 	buffer->height = height;

  0002c	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0002f	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  00032	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 209  : 	int bytesPerPixel = 4;

  00035	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR _bytesPerPixel$[ebp], 4

; 210  : 
; 211  : 	buffer->info.bmiHeader.biSize = sizeof(buffer->info.bmiHeader);

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0003f	c7 01 28 00 00
	00		 mov	 DWORD PTR [ecx], 40	; 00000028H

; 212  : 	buffer->info.bmiHeader.biWidth = buffer->width;

  00045	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00048	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0004b	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0004e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 213  : 	buffer->info.bmiHeader.biHeight = -buffer->height;

  00051	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00054	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00057	f7 d8		 neg	 eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0005c	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 214  : 	buffer->info.bmiHeader.biPlanes = 1;

  0005f	ba 01 00 00 00	 mov	 edx, 1
  00064	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00067	66 89 50 0c	 mov	 WORD PTR [eax+12], dx

; 215  : 	buffer->info.bmiHeader.biBitCount = 32;

  0006b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00070	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00073	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx

; 216  : 	buffer->info.bmiHeader.biCompression = BI_RGB;

  00077	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0007a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 217  : 
; 218  : 	int bitmapMemorySize = (buffer->width * buffer->height) * bytesPerPixel;

  00081	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00084	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00087	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0008a	0f af 42 34	 imul	 eax, DWORD PTR [edx+52]
  0008e	0f af 45 fc	 imul	 eax, DWORD PTR _bytesPerPixel$[ebp]
  00092	89 45 f8	 mov	 DWORD PTR _bitmapMemorySize$[ebp], eax

; 219  : 	buffer->memory = VirtualAlloc(0, bitmapMemorySize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  00095	6a 04		 push	 4
  00097	68 00 30 00 00	 push	 12288			; 00003000H
  0009c	8b 4d f8	 mov	 ecx, DWORD PTR _bitmapMemorySize$[ebp]
  0009f	51		 push	 ecx
  000a0	6a 00		 push	 0
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
  000a8	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  000ab	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 220  : 	buffer->pitch = width * bytesPerPixel;

  000ae	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  000b1	0f af 45 fc	 imul	 eax, DWORD PTR _bytesPerPixel$[ebp]
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000b8	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 221  : 
; 222  : }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
?Win32ResizeDIBSection@@YAXPAUoffscreen_buffer@@HH@Z ENDP ; Win32ResizeDIBSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_row$ = -20						; size = 4
_pixel$1 = -16						; size = 4
_y$2 = -12						; size = 4
_x$3 = -8						; size = 4
_red$4 = -3						; size = 1
_green$5 = -2						; size = 1
_blue$6 = -1						; size = 1
_buffer$ = 8						; size = 4
_blueOffset$ = 12					; size = 4
_greenOffset$ = 16					; size = 4
?Win32RenderColor@@YAXPAUoffscreen_buffer@@HH@Z PROC	; Win32RenderColor

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 178  : 
; 179  : 	uint8* row = (uint8*)buffer->memory;

  00006	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00009	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0000c	89 4d ec	 mov	 DWORD PTR _row$[ebp], ecx

; 180  : 	for (int y = 0; y < buffer->height; ++y)

  0000f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  00016	eb 09		 jmp	 SHORT $LN4@Win32Rende
$LN2@Win32Rende:
  00018	8b 55 f4	 mov	 edx, DWORD PTR _y$2[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 f4	 mov	 DWORD PTR _y$2[ebp], edx
$LN4@Win32Rende:
  00021	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00024	8b 4d f4	 mov	 ecx, DWORD PTR _y$2[ebp]
  00027	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  0002a	7d 64		 jge	 SHORT $LN1@Win32Rende

; 181  : 	{
; 182  : 		uint32* pixel = (uint32*)row;

  0002c	8b 55 ec	 mov	 edx, DWORD PTR _row$[ebp]
  0002f	89 55 f0	 mov	 DWORD PTR _pixel$1[ebp], edx

; 183  : 		for (int x = 0; x < buffer->width; ++x)

  00032	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$3[ebp], 0
  00039	eb 09		 jmp	 SHORT $LN7@Win32Rende
$LN5@Win32Rende:
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _x$3[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 f8	 mov	 DWORD PTR _x$3[ebp], eax
$LN7@Win32Rende:
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00047	8b 55 f8	 mov	 edx, DWORD PTR _x$3[ebp]
  0004a	3b 51 30	 cmp	 edx, DWORD PTR [ecx+48]
  0004d	7d 33		 jge	 SHORT $LN6@Win32Rende

; 184  : 		{
; 185  : 			/*
; 186  : 			* Memory:	BB GG RR xx
; 187  : 			* Register:	xx RR GG BB
; 188  : 			*/
; 189  : 			uint8 blue = (x + blueOffset);

  0004f	8b 45 f8	 mov	 eax, DWORD PTR _x$3[ebp]
  00052	03 45 0c	 add	 eax, DWORD PTR _blueOffset$[ebp]
  00055	88 45 ff	 mov	 BYTE PTR _blue$6[ebp], al

; 190  : 			uint8 green = (y + greenOffset);

  00058	8b 4d f4	 mov	 ecx, DWORD PTR _y$2[ebp]
  0005b	03 4d 10	 add	 ecx, DWORD PTR _greenOffset$[ebp]
  0005e	88 4d fe	 mov	 BYTE PTR _green$5[ebp], cl

; 191  : 			uint8 red = (0);

  00061	c6 45 fd 00	 mov	 BYTE PTR _red$4[ebp], 0

; 192  : 
; 193  : 			*pixel++ = (blue | (green << 8));// | (red << 16));

  00065	0f b6 55 ff	 movzx	 edx, BYTE PTR _blue$6[ebp]
  00069	0f b6 45 fe	 movzx	 eax, BYTE PTR _green$5[ebp]
  0006d	c1 e0 08	 shl	 eax, 8
  00070	0b d0		 or	 edx, eax
  00072	8b 4d f0	 mov	 ecx, DWORD PTR _pixel$1[ebp]
  00075	89 11		 mov	 DWORD PTR [ecx], edx
  00077	8b 55 f0	 mov	 edx, DWORD PTR _pixel$1[ebp]
  0007a	83 c2 04	 add	 edx, 4
  0007d	89 55 f0	 mov	 DWORD PTR _pixel$1[ebp], edx

; 194  : 		}

  00080	eb b9		 jmp	 SHORT $LN5@Win32Rende
$LN6@Win32Rende:

; 195  : 
; 196  : 		row += buffer->pitch;

  00082	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00085	8b 4d ec	 mov	 ecx, DWORD PTR _row$[ebp]
  00088	03 48 38	 add	 ecx, DWORD PTR [eax+56]
  0008b	89 4d ec	 mov	 DWORD PTR _row$[ebp], ecx

; 197  : 	}

  0008e	eb 88		 jmp	 SHORT $LN2@Win32Rende
$LN1@Win32Rende:

; 198  : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?Win32RenderColor@@YAXPAUoffscreen_buffer@@HH@Z ENDP	; Win32RenderColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_result$ = -28						; size = 8
_ClientRect$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_Window$ = 8						; size = 4
?Win32GetWindowDimensions@@YA?AUwindow_dimensions@@PAUHWND__@@@Z PROC ; Win32GetWindowDimensions

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 166  : 	window_dimensions result;
; 167  : 
; 168  : 	RECT ClientRect;
; 169  : 	GetClientRect(Window, &ClientRect);

  00010	8d 45 ec	 lea	 eax, DWORD PTR _ClientRect$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _Window$[ebp]
  00017	51		 push	 ecx
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 170  : 	result.width = ClientRect.right - ClientRect.left;

  0001e	8b 55 f4	 mov	 edx, DWORD PTR _ClientRect$[ebp+8]
  00021	2b 55 ec	 sub	 edx, DWORD PTR _ClientRect$[ebp]
  00024	89 55 e4	 mov	 DWORD PTR _result$[ebp], edx

; 171  : 	result.height = ClientRect.bottom - ClientRect.top;

  00027	8b 45 f8	 mov	 eax, DWORD PTR _ClientRect$[ebp+12]
  0002a	2b 45 f0	 sub	 eax, DWORD PTR _ClientRect$[ebp+4]
  0002d	89 45 e8	 mov	 DWORD PTR _result$[ebp+4], eax

; 172  : 
; 173  : 	return(result);

  00030	8b 45 e4	 mov	 eax, DWORD PTR _result$[ebp]
  00033	8b 55 e8	 mov	 edx, DWORD PTR _result$[ebp+4]

; 174  : }

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00039	33 cd		 xor	 ecx, ebp
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?Win32GetWindowDimensions@@YA?AUwindow_dimensions@@PAUHWND__@@@Z ENDP ; Win32GetWindowDimensions
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_secondaryBuffer$1 = -116				; size = 4
_primaryBuffer$2 = -112					; size = 4
_DirectSoundCreate$3 = -108				; size = 4
_library$ = -104					; size = 4
_directSound$4 = -100					; size = 4
_bufferDescription$5 = -96				; size = 36
_bufferDescription$6 = -60				; size = 36
_waveFormat$7 = -24					; size = 18
__$ArrayPad$ = -4					; size = 4
_Window$ = 8						; size = 4
_samplesPerSecond$ = 12					; size = 4
_bufferSize$ = 16					; size = 4
?Win32InitDSound@@YAXPAUHWND__@@HH@Z PROC		; Win32InitDSound

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 93   : 	HMODULE library = LoadLibraryA("dsound.dll");

  00010	68 00 00 00 00	 push	 OFFSET $SG94383
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0001b	89 45 98	 mov	 DWORD PTR _library$[ebp], eax

; 94   : 	if (library)

  0001e	83 7d 98 00	 cmp	 DWORD PTR _library$[ebp], 0
  00022	0f 84 39 01 00
	00		 je	 $LN1@Win32InitD

; 95   : 	{
; 96   : 		direct_sound_create* DirectSoundCreate = (direct_sound_create*)GetProcAddress(library, "DirectSoundCreate");

  00028	68 00 00 00 00	 push	 OFFSET $SG94386
  0002d	8b 45 98	 mov	 eax, DWORD PTR _library$[ebp]
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00037	89 45 94	 mov	 DWORD PTR _DirectSoundCreate$3[ebp], eax

; 97   : 
; 98   : 		LPDIRECTSOUND directSound;
; 99   : 		if (DirectSoundCreate && SUCCEEDED(DirectSoundCreate(0, &directSound, 0)))

  0003a	83 7d 94 00	 cmp	 DWORD PTR _DirectSoundCreate$3[ebp], 0
  0003e	0f 84 1d 01 00
	00		 je	 $LN1@Win32InitD
  00044	6a 00		 push	 0
  00046	8d 4d 9c	 lea	 ecx, DWORD PTR _directSound$4[ebp]
  00049	51		 push	 ecx
  0004a	6a 00		 push	 0
  0004c	ff 55 94	 call	 DWORD PTR _DirectSoundCreate$3[ebp]
  0004f	85 c0		 test	 eax, eax
  00051	0f 8c 0a 01 00
	00		 jl	 $LN1@Win32InitD

; 100  : 		{
; 101  : 			WAVEFORMATEX waveFormat;
; 102  : 			waveFormat.wFormatTag = WAVE_FORMAT_PCM;

  00057	ba 01 00 00 00	 mov	 edx, 1
  0005c	66 89 55 e8	 mov	 WORD PTR _waveFormat$7[ebp], dx

; 103  : 			waveFormat.nChannels = 2;

  00060	b8 02 00 00 00	 mov	 eax, 2
  00065	66 89 45 ea	 mov	 WORD PTR _waveFormat$7[ebp+2], ax

; 104  : 			waveFormat.nSamplesPerSec = samplesPerSecond;

  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _samplesPerSecond$[ebp]
  0006c	89 4d ec	 mov	 DWORD PTR _waveFormat$7[ebp+4], ecx

; 105  : 			waveFormat.wBitsPerSample = 16;

  0006f	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00074	66 89 55 f6	 mov	 WORD PTR _waveFormat$7[ebp+14], dx

; 106  : 			waveFormat.nBlockAlign = (waveFormat.nChannels * waveFormat.wBitsPerSample) / 8;

  00078	0f b7 45 ea	 movzx	 eax, WORD PTR _waveFormat$7[ebp+2]
  0007c	0f b7 4d f6	 movzx	 ecx, WORD PTR _waveFormat$7[ebp+14]
  00080	0f af c1	 imul	 eax, ecx
  00083	99		 cdq
  00084	83 e2 07	 and	 edx, 7
  00087	03 c2		 add	 eax, edx
  00089	c1 f8 03	 sar	 eax, 3
  0008c	66 89 45 f4	 mov	 WORD PTR _waveFormat$7[ebp+12], ax

; 107  : 			waveFormat.nAvgBytesPerSec = waveFormat.nSamplesPerSec * waveFormat.nBlockAlign;

  00090	0f b7 55 f4	 movzx	 edx, WORD PTR _waveFormat$7[ebp+12]
  00094	0f af 55 ec	 imul	 edx, DWORD PTR _waveFormat$7[ebp+4]
  00098	89 55 f0	 mov	 DWORD PTR _waveFormat$7[ebp+8], edx

; 108  : 			waveFormat.cbSize = 0;

  0009b	33 c0		 xor	 eax, eax
  0009d	66 89 45 f8	 mov	 WORD PTR _waveFormat$7[ebp+16], ax

; 109  : 
; 110  : 			if (SUCCEEDED(directSound->SetCooperativeLevel(Window, DSSCL_PRIORITY)))

  000a1	6a 02		 push	 2
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _Window$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 55 9c	 mov	 edx, DWORD PTR _directSound$4[ebp]
  000aa	8b 02		 mov	 eax, DWORD PTR [edx]
  000ac	8b 4d 9c	 mov	 ecx, DWORD PTR _directSound$4[ebp]
  000af	51		 push	 ecx
  000b0	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000b3	ff d2		 call	 edx
  000b5	85 c0		 test	 eax, eax
  000b7	7c 59		 jl	 SHORT $LN7@Win32InitD

; 111  : 			{
; 112  : 				DSBUFFERDESC bufferDescription = {};

  000b9	33 c0		 xor	 eax, eax
  000bb	89 45 c4	 mov	 DWORD PTR _bufferDescription$6[ebp], eax
  000be	89 45 c8	 mov	 DWORD PTR _bufferDescription$6[ebp+4], eax
  000c1	89 45 cc	 mov	 DWORD PTR _bufferDescription$6[ebp+8], eax
  000c4	89 45 d0	 mov	 DWORD PTR _bufferDescription$6[ebp+12], eax
  000c7	89 45 d4	 mov	 DWORD PTR _bufferDescription$6[ebp+16], eax
  000ca	89 45 d8	 mov	 DWORD PTR _bufferDescription$6[ebp+20], eax
  000cd	89 45 dc	 mov	 DWORD PTR _bufferDescription$6[ebp+24], eax
  000d0	89 45 e0	 mov	 DWORD PTR _bufferDescription$6[ebp+28], eax
  000d3	89 45 e4	 mov	 DWORD PTR _bufferDescription$6[ebp+32], eax

; 113  : 				bufferDescription.dwSize = sizeof(bufferDescription);

  000d6	c7 45 c4 24 00
	00 00		 mov	 DWORD PTR _bufferDescription$6[ebp], 36 ; 00000024H

; 114  : 				bufferDescription.dwFlags = DSBCAPS_PRIMARYBUFFER;

  000dd	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _bufferDescription$6[ebp+4], 1

; 115  : 				LPDIRECTSOUNDBUFFER primaryBuffer;
; 116  : 				if (SUCCEEDED(directSound->CreateSoundBuffer(&bufferDescription, &primaryBuffer, 0)))

  000e4	6a 00		 push	 0
  000e6	8d 4d 90	 lea	 ecx, DWORD PTR _primaryBuffer$2[ebp]
  000e9	51		 push	 ecx
  000ea	8d 55 c4	 lea	 edx, DWORD PTR _bufferDescription$6[ebp]
  000ed	52		 push	 edx
  000ee	8b 45 9c	 mov	 eax, DWORD PTR _directSound$4[ebp]
  000f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f3	8b 55 9c	 mov	 edx, DWORD PTR _directSound$4[ebp]
  000f6	52		 push	 edx
  000f7	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000fa	ff d0		 call	 eax
  000fc	85 c0		 test	 eax, eax
  000fe	7c 12		 jl	 SHORT $LN7@Win32InitD

; 117  : 				{
; 118  : 					if (SUCCEEDED(primaryBuffer->SetFormat(&waveFormat)))

  00100	8d 4d e8	 lea	 ecx, DWORD PTR _waveFormat$7[ebp]
  00103	51		 push	 ecx
  00104	8b 55 90	 mov	 edx, DWORD PTR _primaryBuffer$2[ebp]
  00107	8b 02		 mov	 eax, DWORD PTR [edx]
  00109	8b 4d 90	 mov	 ecx, DWORD PTR _primaryBuffer$2[ebp]
  0010c	51		 push	 ecx
  0010d	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  00110	ff d2		 call	 edx
$LN7@Win32InitD:

; 119  : 					{
; 120  : 
; 121  : 					}
; 122  : 					else
; 123  : 					{
; 124  : 						// log diagnostic
; 125  : 					}
; 126  : 				}
; 127  : 				else
; 128  : 				{
; 129  : 					// log diagnostic
; 130  : 				}
; 131  : 			}
; 132  : 			else
; 133  : 			{
; 134  : 				// log diagnostic
; 135  : 			}
; 136  : 
; 137  : 			DSBUFFERDESC bufferDescription = {};

  00112	33 c0		 xor	 eax, eax
  00114	89 45 a0	 mov	 DWORD PTR _bufferDescription$5[ebp], eax
  00117	89 45 a4	 mov	 DWORD PTR _bufferDescription$5[ebp+4], eax
  0011a	89 45 a8	 mov	 DWORD PTR _bufferDescription$5[ebp+8], eax
  0011d	89 45 ac	 mov	 DWORD PTR _bufferDescription$5[ebp+12], eax
  00120	89 45 b0	 mov	 DWORD PTR _bufferDescription$5[ebp+16], eax
  00123	89 45 b4	 mov	 DWORD PTR _bufferDescription$5[ebp+20], eax
  00126	89 45 b8	 mov	 DWORD PTR _bufferDescription$5[ebp+24], eax
  00129	89 45 bc	 mov	 DWORD PTR _bufferDescription$5[ebp+28], eax
  0012c	89 45 c0	 mov	 DWORD PTR _bufferDescription$5[ebp+32], eax

; 138  : 			bufferDescription.dwSize = sizeof(bufferDescription);

  0012f	c7 45 a0 24 00
	00 00		 mov	 DWORD PTR _bufferDescription$5[ebp], 36 ; 00000024H

; 139  : 			bufferDescription.dwFlags = 0;

  00136	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _bufferDescription$5[ebp+4], 0

; 140  : 			bufferDescription.dwBufferBytes = bufferSize;

  0013d	8b 4d 10	 mov	 ecx, DWORD PTR _bufferSize$[ebp]
  00140	89 4d a8	 mov	 DWORD PTR _bufferDescription$5[ebp+8], ecx

; 141  : 			bufferDescription.lpwfxFormat = &waveFormat;

  00143	8d 55 e8	 lea	 edx, DWORD PTR _waveFormat$7[ebp]
  00146	89 55 b0	 mov	 DWORD PTR _bufferDescription$5[ebp+16], edx

; 142  : 			LPDIRECTSOUNDBUFFER secondaryBuffer;
; 143  : 			if (SUCCEEDED(directSound->CreateSoundBuffer(&bufferDescription, &secondaryBuffer, 0)))

  00149	6a 00		 push	 0
  0014b	8d 45 8c	 lea	 eax, DWORD PTR _secondaryBuffer$1[ebp]
  0014e	50		 push	 eax
  0014f	8d 4d a0	 lea	 ecx, DWORD PTR _bufferDescription$5[ebp]
  00152	51		 push	 ecx
  00153	8b 55 9c	 mov	 edx, DWORD PTR _directSound$4[ebp]
  00156	8b 02		 mov	 eax, DWORD PTR [edx]
  00158	8b 4d 9c	 mov	 ecx, DWORD PTR _directSound$4[ebp]
  0015b	51		 push	 ecx
  0015c	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0015f	ff d2		 call	 edx
$LN1@Win32InitD:

; 144  : 			{
; 145  : 
; 146  : 			}
; 147  : 			else
; 148  : 			{
; 149  : 				// log diagnostic
; 150  : 			}
; 151  : 		}
; 152  : 		else
; 153  : 		{
; 154  : 			// log diagnostic
; 155  : 		}
; 156  : 	}
; 157  : 	else
; 158  : 	{
; 159  : 		// log diagnostic
; 160  : 	}
; 161  : 
; 162  : }

  00161	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00164	33 cd		 xor	 ecx, ebp
  00166	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c3		 ret	 0
?Win32InitDSound@@YAXPAUHWND__@@HH@Z ENDP		; Win32InitDSound
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_library$ = -4						; size = 4
?Win32LoadXInput@@YAXXZ PROC				; Win32LoadXInput

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 69   : 	HMODULE library = LoadLibraryA("xinput1_4.dll");

  00004	68 00 00 00 00	 push	 OFFSET $SG94356
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0000f	89 45 fc	 mov	 DWORD PTR _library$[ebp], eax

; 70   : 	if (library)

  00012	83 7d fc 00	 cmp	 DWORD PTR _library$[ebp], 0
  00016	74 4e		 je	 SHORT $LN1@Win32LoadX

; 71   : 	{
; 72   : 		XInputGetState = (x_input_get_state*)GetProcAddress(library, "XInputGetState");

  00018	68 00 00 00 00	 push	 OFFSET $SG94359
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _library$[ebp]
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00027	a3 00 00 00 00	 mov	 DWORD PTR ?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA, eax

; 73   : 		if (!XInputGetState) {

  0002c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA, 0
  00033	75 0a		 jne	 SHORT $LN4@Win32LoadX

; 74   : 			XInputGetState = XInputGetStateStub;

  00035	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?xInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA, OFFSET ?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z ; XInputGetStateStub
$LN4@Win32LoadX:

; 75   : 		}
; 76   : 		xInputSetState_ = (x_input_set_state*)GetProcAddress(library, "XInputSetState");

  0003f	68 00 00 00 00	 push	 OFFSET $SG94361
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _library$[ebp]
  00047	51		 push	 ecx
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0004e	a3 00 00 00 00	 mov	 DWORD PTR ?xInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA, eax

; 77   : 		if (!XInputSetState) {

  00053	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?xInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA, 0
  0005a	75 0a		 jne	 SHORT $LN1@Win32LoadX

; 78   : 			XInputSetState = XInputSetStateStub;

  0005c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?xInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA, OFFSET ?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ; XInputSetStateStub
$LN1@Win32LoadX:

; 79   : 		}
; 80   : 		else
; 81   : 		{
; 82   : 			// log diagnostic
; 83   : 		}
; 84   : 	}
; 85   : 	else
; 86   : 	{
; 87   : 		// log diagnostic
; 88   : 	}
; 89   : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?Win32LoadXInput@@YAXXZ ENDP				; Win32LoadXInput
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_dwUserIndex$ = 8					; size = 4
_pVibration$ = 12					; size = 4
?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z PROC	; XInputSetStateStub

; 47   : XINPUT_SET_STATE(XInputSetStateStub) { return(ERROR_DEVICE_NOT_CONNECTED); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 8f 04 00 00	 mov	 eax, 1167		; 0000048fH
  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ENDP	; XInputSetStateStub
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_dwUserIndex$ = 8					; size = 4
_pState$ = 12						; size = 4
?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z PROC	; XInputGetStateStub

; 46   : XINPUT_GET_STATE(XInputGetStateStub) { return(ERROR_DEVICE_NOT_CONNECTED); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 8f 04 00 00	 mov	 eax, 1167		; 0000048fH
  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z ENDP	; XInputGetStateStub
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\WindowsGame\BareBones\code\win32_barebones.cpp
_TEXT	SEGMENT
_Instance$ = 8						; size = 4
_PrevInstance$ = 12					; size = 4
_CmdLine$ = 16						; size = 4
_ShowCode$ = 20						; size = 4
_WinMain@16 PROC

; 476  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 477  : 	main(Instance);

  00003	8b 45 08	 mov	 eax, DWORD PTR _Instance$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _main
  0000c	83 c4 04	 add	 esp, 4

; 478  : 
; 479  : 	return(0);

  0000f	33 c0		 xor	 eax, eax

; 480  : }

  00011	5d		 pop	 ebp
  00012	c2 10 00	 ret	 16			; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
END
